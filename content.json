{"meta":{"title":"Diamond","subtitle":"我走的很慢,但是我从来不会后退","description":null,"author":"Mr.sun","url":"https://diamond-sjh.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"09-29","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"09-29","excerpt":""}],"posts":[{"title":"unipush的蓝牙模块2","text":"unipush的蓝牙模块–经典蓝牙一、核心js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475/** * html+ 经典蓝牙操作 * 2021.07.21 uni-app版本 * @auth boolTrue *//** * 初始化参数 */ //#ifdef APP-PLUSlet BluetoothAdapter = plus.android.importClass(&quot;android.bluetooth.BluetoothAdapter&quot;);let Intent = plus.android.importClass(&quot;android.content.Intent&quot;);let IntentFilter = plus.android.importClass(&quot;android.content.IntentFilter&quot;);let BluetoothDevice = plus.android.importClass(&quot;android.bluetooth.BluetoothDevice&quot;);let UUID = plus.android.importClass(&quot;java.util.UUID&quot;);let Toast = plus.android.importClass(&quot;android.widget.Toast&quot;);//连接串口设备的 UUIDlet MY_UUID = UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;);let invoke = plus.android.invoke;let btAdapter = BluetoothAdapter.getDefaultAdapter();let activity = plus.android.runtimeMainActivity();let btSocket = null;let btInStream = null;let btOutStream = null;let setIntervalId = 0;let btFindReceiver = null; //蓝牙搜索广播接收器let btStatusReceiver = null; //蓝牙状态监听广播//#endif/** * 构造对象 */ var blueToothTool = &#123; state : &#123; bluetoothEnable: false, //蓝牙是否开启 bluetoothState: &quot;&quot;, //当前蓝牙状态 discoveryDeviceState: false, //是否正在搜索蓝牙设备 readThreadState: false, //数据读取线程状态 &#125;, options : &#123; /** * 监听蓝牙状态回调 * @param &#123;String&#125; state */ listenBTStatusCallback: function(state) &#123;&#125;, /** * 搜索到新的蓝牙设备回调 * @param &#123;Device&#125; newDevice */ discoveryDeviceCallback: function(newDevice) &#123;&#125;, /** * 蓝牙搜索完成回调 */ discoveryFinishedCallback: function() &#123;&#125;, /** * 接收到数据回调 * @param &#123;Array&#125; dataByteArr */ readDataCallback: function(dataByteArr) &#123; console.log(dataByteArr) &#125;, /** * 蓝牙连接中断回调 * @param &#123;Exception&#125; e */ connExceptionCallback: function(e) &#123;&#125; &#125;, init(setOptions) &#123; Object.assign(this.options, setOptions); this.state.bluetoothEnable = this.getBluetoothStatus(); this.listenBluetoothStatus(); &#125;, shortToast(msg) &#123; Toast.makeText(activity, msg, Toast.LENGTH_SHORT).show(); &#125;, /** * 是否支持蓝牙 * @return &#123;boolean&#125; */ isSupportBluetooth() &#123; if(btAdapter != null) &#123; return true; &#125; return false; &#125;, /** * 获取蓝牙的状态 * @return &#123;boolean&#125; 是否已开启 */ getBluetoothStatus() &#123; if(btAdapter != null) &#123; return btAdapter.isEnabled(); &#125; return false; &#125;, /** * 打开蓝牙 * @param activity * @param requestCode */ turnOnBluetooth() &#123; if(btAdapter == null) &#123; this.shortToast(&quot;没有蓝牙&quot;); return; &#125; if(!btAdapter.isEnabled()) &#123; if(activity == null) &#123; this.shortToast(&quot;未获取到activity&quot;); return; &#125; else &#123; let intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); let requestCode = 1; activity.startActivityForResult(intent, requestCode); return; &#125; &#125; else &#123; this.shortToast(&quot;蓝牙已经打开&quot;); &#125; &#125;, /** * 关闭蓝牙 */ turnOffBluetooth() &#123; if(btAdapter != null &amp;&amp; btAdapter.isEnabled()) &#123; btAdapter.disable(); &#125; if(btFindReceiver != null) &#123; try &#123; activity.unregisterReceiver(btFindReceiver); &#125; catch(e) &#123; &#125; btFindReceiver = null; &#125; this.state.bluetoothEnable = false; this.cancelDiscovery(); this.closeBtSocket(); if(btAdapter != null &amp;&amp; btAdapter.isEnabled()) &#123; btAdapter.disable(); this.shortToast(&quot;蓝牙关闭成功&quot;); &#125; else &#123; this.shortToast(&quot;蓝牙已经关闭&quot;); &#125; &#125;, /** * 获取已经配对的设备 * @return &#123;Array&#125; connetedDevices */ getPairedDevices() &#123; let pairedDevices = []; //蓝牙连接android原生对象，是一个set集合 let pairedDevicesAndroid = null; if(btAdapter != null &amp;&amp; btAdapter.isEnabled()) &#123; pairedDevicesAndroid = btAdapter.getBondedDevices(); &#125; else &#123; this.shortToast(&quot;蓝牙未开启&quot;); &#125; if(!pairedDevicesAndroid) &#123; return pairedDevices; &#125; //遍历连接设备的set集合，转换为js数组 let it = invoke(pairedDevicesAndroid, &quot;iterator&quot;); while(invoke(it, &quot;hasNext&quot;)) &#123; let device = invoke(it, &quot;next&quot;); pairedDevices.push(&#123; &quot;name&quot;: invoke(device, &quot;getName&quot;), &quot;address&quot;: invoke(device, &quot;getAddress&quot;) &#125;); &#125; return pairedDevices; &#125;, /** * 发现设备 */ discoveryNewDevice() &#123; let that = this if(btFindReceiver != null) &#123; try &#123; activity.unregisterReceiver(btFindReceiver); &#125; catch(e) &#123; console.error(e); &#125; btFindReceiver = null; this.cancelDiscovery(); &#125; // 获取安卓的一些系统信息 let Build = plus.android.importClass(&quot;android.os.Build&quot;); console.log(Build.VERSION.SDK_INT) //6.0以后的如果需要利用本机查找周围的wifi和蓝牙设备, 申请权限 if(Build.VERSION.SDK_INT &gt;= 6.0)&#123; plus.android.requestPermissions( [&#x27;android.permission.BLUETOOTH&#x27;, &#x27;android.permission.BLUETOOTH_ADMIN&#x27;, &#x27;android.permission.WRITE_EXTERNAL_STORAGE&#x27;, &#x27;android.permission.ACCESS_COARSE_LOCATION&#x27;, &#x27;android.permission.ACCESS_FINE_LOCATION&#x27;]) &#125; let options = this.options btFindReceiver = plus.android.implements(&quot;io.dcloud.android.content.BroadcastReceiver&quot;, &#123; &quot;onReceive&quot;: function(context, intent) &#123; plus.android.importClass(context); plus.android.importClass(intent); let action = intent.getAction(); if(BluetoothDevice.ACTION_FOUND == action) &#123; // 找到设备 let device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); let newDevice = &#123; &quot;name&quot;: plus.android.invoke(device, &quot;getName&quot;), &quot;address&quot;: plus.android.invoke(device, &quot;getAddress&quot;) &#125; options.discoveryDeviceCallback &amp;&amp; options.discoveryDeviceCallback(newDevice); &#125; if(BluetoothAdapter.ACTION_DISCOVERY_FINISHED == action) &#123; // 搜索完成 options.discoveryFinishedCallback &amp;&amp; options.discoveryFinishedCallback(); that.cancelDiscovery(); &#125; &#125; &#125;); let filter = new IntentFilter(); filter.addAction(BluetoothDevice.ACTION_FOUND); filter.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); activity.registerReceiver(btFindReceiver, filter); btAdapter.startDiscovery(); //开启搜索 this.state.discoveryDeviceState = true; &#125;, /** * 蓝牙状态监听 * @param &#123;Activity&#125; activity */ listenBluetoothStatus() &#123; if(btStatusReceiver != null) &#123; try &#123; activity.unregisterReceiver(btStatusReceiver); &#125; catch(e) &#123; console.error(e); &#125; btStatusReceiver = null; &#125; btStatusReceiver = plus.android.implements(&quot;io.dcloud.android.content.BroadcastReceiver&quot;, &#123; &quot;onReceive&quot;: (context, intent)=&gt; &#123; plus.android.importClass(context); plus.android.importClass(intent); let action = intent.getAction(); switch(action) &#123; case BluetoothAdapter.ACTION_STATE_CHANGED: let blueState = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, 0); let stateStr = &quot;&quot;; switch(blueState) &#123; case BluetoothAdapter.STATE_TURNING_ON: stateStr = &quot;STATE_TURNING_ON&quot;; break; case BluetoothAdapter.STATE_ON: this.state.bluetoothEnable = true; stateStr = &quot;STATE_ON&quot;; break; case BluetoothAdapter.STATE_TURNING_OFF: stateStr = &quot;STATE_TURNING_OFF&quot;; break; case BluetoothAdapter.STATE_OFF: stateStr = &quot;STATE_OFF&quot;; this.state.bluetoothEnable = false; break; &#125; this.state.bluetoothState = stateStr; this.options.listenBTStatusCallback &amp;&amp; this.options.listenBTStatusCallback(stateStr); break; &#125; &#125; &#125;); let filter = new IntentFilter(); filter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED); activity.registerReceiver(btStatusReceiver, filter); // 首次连接 状态回调 if(this.state.bluetoothEnable) &#123; this.options.listenBTStatusCallback &amp;&amp; this.options.listenBTStatusCallback(&#x27;STATE_ON&#x27;); &#125; &#125;, /** * 根据蓝牙地址，连接设备 * @param &#123;Stirng&#125; address * @return &#123;Boolean&#125; */ connDevice(address, callback) &#123; // 字节输入流 let InputStream = plus.android.importClass(&quot;java.io.InputStream&quot;); // 字节输出流 let OutputStream = plus.android.importClass(&quot;java.io.OutputStream&quot;); // 建立RFCOMM通道(SPP协议),蓝牙Socket接口(类似TCP Socket),通过InputStream和OutputStream与其他设备传输数据 let BluetoothSocket = plus.android.importClass(&quot;android.bluetooth.BluetoothSocket&quot;); // 取消发现蓝牙 this.cancelDiscovery(); if(btSocket != null) &#123; this.closeBtSocket(); &#125; this.state.readThreadState = false; try &#123; // 根据蓝牙地址获取远程蓝牙设备 let device = invoke(btAdapter, &quot;getRemoteDevice&quot;, address); // 根据UUID创建并返回一个BluetoothSocket,代表一个蓝牙socket的接口（和TCP Socket类似） btSocket = invoke(device, &quot;createRfcommSocketToServiceRecord&quot;, MY_UUID); &#125; catch(e) &#123; console.error(e); this.shortToast(&quot;连接失败，获取Socket失败！&quot;); callback(false) return false; &#125; try &#123; invoke(btSocket, &quot;connect&quot;); this.readData(); //读数据 this.shortToast(&quot;连接成功&quot;); callback(true) &#125; catch(e) &#123; console.error(e); this.shortToast(&quot;连接失败&quot;); callback(false) try &#123; btSocket.close(); btSocket = null; &#125; catch(e1) &#123; console.error(e1); &#125; return false; &#125; return true; &#125;, /** * 断开连接设备 * @param &#123;Object&#125; address * @return &#123;Boolean&#125; */ disConnDevice() &#123; if(btSocket != null) &#123; this.closeBtSocket(); &#125; this.state.readThreadState = false; this.shortToast(&quot;断开连接成功&quot;); &#125;, /** * 断开连接设备 * @param &#123;Object&#125; address * @return &#123;Boolean&#125; */ closeBtSocket() &#123; this.state.readThreadState = false; if(!btSocket) &#123; return; &#125; try &#123; btSocket.close(); &#125; catch(e) &#123; console.error(e); btSocket = null; &#125; &#125;, /** * 取消发现 */ cancelDiscovery() &#123; if(btAdapter.isDiscovering()) &#123; btAdapter.cancelDiscovery(); &#125; if(btFindReceiver != null) &#123; activity.unregisterReceiver(btFindReceiver); btFindReceiver = null; &#125; this.state.discoveryDeviceState = false; &#125;, /** * 读取数据 * @param &#123;Object&#125; activity * @param &#123;Function&#125; callback * @return &#123;Boolean&#125; */ readData() &#123; if(!btSocket) &#123; this.shortToast(&quot;请先连接蓝牙设备！&quot;); return false; &#125; try &#123; // 获取输入流 btInStream = invoke(btSocket, &quot;getInputStream&quot;); // 获取输出流 btOutStream = invoke(btSocket, &quot;getOutputStream&quot;); &#125; catch(e) &#123; console.error(e); this.shortToast(&quot;创建输入输出流失败！&quot;); this.closeBtSocket(); return false; &#125; this.read(); this.state.readThreadState = true; return true; &#125;, /** * 模拟java多线程读取数据 */ read() &#123; let setTimeCount = 0; clearInterval(setIntervalId); setIntervalId = setInterval(()=&gt; &#123; setTimeCount++; if(this.state.readThreadState) &#123; let t = new Date().getTime(); //心跳检测 if(setTimeCount % 20 == 0) &#123; try &#123; btOutStream.write([0b00]); &#125; catch(e) &#123; this.state.readThreadState = false; this.options.connExceptionCallback &amp;&amp; this.options.connExceptionCallback(e); &#125; &#125; let tmp = &#x27;&#x27; let dataArr = [] while(invoke(btInStream, &quot;available&quot;) !== 0) &#123; let data = invoke(btInStream, &quot;read&quot;); tmp = String.fromCharCode(data) if(tmp.length == 1)&#123; tmp = &#x27;0&#x27; + tmp &#125; dataArr.push(tmp); let ct = new Date().getTime(); if(ct - t &gt; 20) &#123; break; &#125; &#125; if(dataArr.length &gt; 0) &#123; this.options.readDataCallback &amp;&amp; this.options.readDataCallback(dataArr); &#125; &#125; &#125;, 40); &#125;, /** * 发送数据 * @param &#123;String&#125; dataStr * @return &#123;Boolean&#125; */ sendData(dataStr) &#123; console.log(dataStr) if(!btOutStream) &#123; this.shortToast(&quot;创建输出流失败！&quot;); return; &#125; let buffer = this.str2ab(dataStr) console.log(buffer) try &#123; btOutStream.write(buffer); &#125; catch(e) &#123; return false; &#125; return true; &#125;, // 字符串转为ArrayBuffer对象，参数为字符串 str2ab(str) &#123; let len = str.length/2 let bytes = [] for (var i=0; i&lt;len; i++) &#123; // 设置占8-bit的字节数组 一个字节 16进制数据 bytes.push(parseInt(str.substring(i*2, i*2+2),16)) &#125; console.log(bytes) return bytes; &#125;&#125;module.exports = blueToothTool 二、调用示例:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206&lt;template&gt; &lt;view&gt; &lt;!-- &lt;button @click&#x3D;&quot;open&quot;&gt;打开&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;close&quot;&gt;关闭&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;searchBle&quot;&gt;搜索蓝牙&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;getBle&quot;&gt;已配对蓝牙&lt;&#x2F;button&gt; &lt;view :key&#x3D;&quot;index&quot; v-for&#x3D;&quot;(item,index) in devices&quot;&gt; &lt;button style&#x3D;&quot;width: 400upx; color: #0081FF;&quot; @click&#x3D;&quot;onConn(item)&quot;&gt;&#123;&#123;item.name&#125;&#125;-----&#123;&#123;item.address&#125;&#125;&lt;&#x2F;button&gt; &lt;&#x2F;view&gt; &lt;textarea style&#x3D;&quot;background-color: pink;&quot; cols&#x3D;&quot;20&quot; rows&#x3D;&quot;4&quot; v-model&#x3D;&quot;sendData&quot;&gt;&lt;&#x2F;textarea&gt; &lt;button style&#x3D;&quot;margin-top: 100upx;&quot; @click&#x3D;&quot;clickSendData&quot;&gt;发送数据&lt;&#x2F;button&gt; --&gt; &lt;button size&#x3D;&quot;mini&quot; @click&#x3D;&quot;open&quot;&gt;打开蓝牙&lt;&#x2F;button&gt; &lt;button size&#x3D;&quot;mini&quot; @click&#x3D;&quot;close&quot;&gt;关闭蓝牙&lt;&#x2F;button&gt; &lt;button size&#x3D;&quot;mini&quot; @click&#x3D;&quot;searchBle&quot;&gt;搜索蓝牙&lt;&#x2F;button&gt; &lt;button size&#x3D;&quot;mini&quot; @click&#x3D;&quot;getBle&quot;&gt;已配对蓝牙&lt;&#x2F;button&gt; &lt;view&gt; &lt;h3&gt;蓝牙状态：&lt;&#x2F;h3&gt; &lt;view class&#x3D;&quot;&quot;&gt;蓝牙是否开启:&#123;&#123;bluetoothState.bluetoothEnable&#125;&#125;&lt;&#x2F;view&gt; &lt;view class&#x3D;&quot;&quot;&gt;当前蓝牙状态:&#123;&#123;bluetoothState.bluetoothState&#125;&#125;&lt;&#x2F;view&gt; &lt;view class&#x3D;&quot;&quot;&gt;是否正在搜索蓝牙设备:&#123;&#123;bluetoothState.discoveryDeviceState&#125;&#125;&lt;&#x2F;view&gt; &lt;view class&#x3D;&quot;&quot;&gt;数据读取线程状态:&#123;&#123;bluetoothState.readThreadState&#125;&#125;&lt;&#x2F;view&gt; &lt;&#x2F;view&gt; &lt;view&gt; &lt;h3&gt;消息：&lt;&#x2F;h3&gt; &#123;&#123;msg&#125;&#125; &lt;&#x2F;view&gt; &lt;view&gt; &lt;button size&#x3D;&quot;mini&quot; @click&#x3D;&quot;disConnDevice&quot;&gt;断开连接&lt;&#x2F;button&gt; &lt;&#x2F;view&gt; &lt;h3&gt;已配对的设备：&lt;&#x2F;h3&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;device in devices&quot;&gt; 名称：&#123;&#123;device.name&#125;&#125;&lt;br&gt; 地址：&#123;&#123;device.address&#125;&#125;&lt;br&gt; &lt;button size&#x3D;&quot;mini&quot; @click&#x3D;&quot;onConn(device)&quot;&gt;连接&lt;&#x2F;button&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;h3&gt;发现的设备：&lt;&#x2F;h3&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;device in newDevices&quot;&gt; 名称：&#123;&#123;device.name&#125;&#125;&lt;br&gt; 地址：&#123;&#123;device.address&#125;&#125;&lt;br&gt; &lt;button size&#x3D;&quot;mini&quot; @click&#x3D;&quot;onConn(device)&quot;&gt;连接&lt;&#x2F;button&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;view&gt; 发送数据： &lt;textarea style&#x3D;&quot;border: 1px solid #cccccc;&quot; cols&#x3D;&quot;20&quot; rows&#x3D;&quot;2&quot; v-model&#x3D;&quot;sendData&quot;&gt;&lt;&#x2F;textarea&gt; &lt;button size&#x3D;&quot;mini&quot; @click&#x3D;&quot;clickSendData&quot;&gt;发送&lt;&#x2F;button&gt; &lt;&#x2F;view&gt; &lt;br&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; import bluetoothTool from &#39;@&#x2F;static&#x2F;BluetoothTool.js&#39; export default &#123; data() &#123; return &#123; devices: [],&#x2F;&#x2F;已配对的设备列表 newDevices: [],&#x2F;&#x2F;搜索的设备列表 bluetoothState:&#39;&#39;,&#x2F;&#x2F;蓝牙状态 msg: &#39;&#39;,&#x2F;&#x2F;消息 sendData:&#39;0A255231512C31373031373A320D0A&#39;, receiveDataArr: [], &#125; &#125;, watch:&#123; msg()&#123; uni.showToast(&#123; title: this.msg &#125;) &#125; &#125;, onLoad: function() &#123; &#125;, mounted() &#123; let that &#x3D; this this.bluetoothState &#x3D; bluetoothTool.state console.log(this.bluetoothState) &#x2F;&#x2F;#ifdef APP-PLUS &#x2F;&#x2F; 蓝牙 bluetoothTool.init(&#123; listenBTStatusCallback: (state)&#x3D;&gt; &#123; if(state &#x3D;&#x3D; &#39;STATE_ON&#39;) &#123; let lastBleAddress &#x3D; uni.getStorageSync(&#39;lastBleAddress&#39;) if(lastBleAddress) &#123; uni.showLoading(&#123; title: &#39;正在连接...&#39; &#125;) console.log(lastBleAddress) bluetoothTool.connDevice(lastBleAddress,(result)&#x3D;&gt;&#123; uni.hideLoading() that.msg &#x3D; &quot;连接成功&quot;; uni.showToast(&#123; title: result?&#39;连接成功！&#39;:&#39;连接失败...&#39; &#125;); &#125;) &#125; &#125; &#125;, discoveryDeviceCallback: this.onDevice, discoveryFinishedCallback: () &#x3D;&gt; &#123; that.msg &#x3D; &quot;搜索完成&quot;; &#125;, readDataCallback: function(dataByteArr) &#123; if(that.receiveDataArr.length &gt;&#x3D; 200) &#123; that.receiveDataArr &#x3D; []; &#125; that.receiveDataArr.push.apply(that.receiveDataArr, dataByteArr); console.log(that.receiveDataArr.join(&#39;&#39;)) &#125;, connExceptionCallback: function(e) &#123; console.log(e); that.msg &#x3D; &quot;设备连接失败&quot;; &#125; &#125;); &#x2F;&#x2F;#endif &#125;, methods: &#123; &#x2F;&#x2F; 打开蓝牙 open()&#123; bluetoothTool.turnOnBluetooth() &#125;, &#x2F;&#x2F; 关闭蓝牙 close()&#123; bluetoothTool.turnOffBluetooth() &#125;, &#x2F;&#x2F; 断开连接 disConnDevice()&#123; bluetoothTool.disConnDevice() &#125;, &#x2F;&#x2F; 获取已配对蓝牙 getBle()&#123; var that &#x3D; this uni.openBluetoothAdapter(&#123; success(res) &#123; that.devices &#x3D; [] console.log(&quot;打开 蓝牙模块，开始搜索模式...&quot;) console.log(res) that.devices &#x3D; bluetoothTool.getPairedDevices(); &#x2F;&#x2F;that.onDevice() &#125; &#125;) &#125;, &#x2F;&#x2F; 搜索蓝牙 searchBle() &#123; var that &#x3D; this console.log(&quot;initBule&quot;) &#x2F;&#x2F; 使用openBluetoothAdapter 接口，免去主动申请权限的麻烦 uni.openBluetoothAdapter(&#123; success(res) &#123; that.devices &#x3D; [] console.log(&quot;打开 蓝牙模块，开始搜索模式...&quot;) console.log(res) bluetoothTool.discoveryNewDevice(); &#x2F;&#x2F;that.onDevice() &#125; &#125;) &#125;, onDevice(newDevice)&#123; console.log(&quot;监听寻找到新设备的事件---------------&quot;) console.log(newDevice) if(this.newDevices.findIndex(value &#x3D;&gt; value.address &#x3D;&#x3D; newDevice.address) &#x3D;&#x3D; -1)&#123; if(newDevice.name &amp;&amp; newDevice.name !&#x3D; &#39;null&#39;) &#123; this.newDevices.push(&#123; name: newDevice.name, address: newDevice.address &#125;) &#125;else&#123; this.newDevices.push(&#123; name: &#39;N&#x2F;A&#39;, address: newDevice.address &#125;) &#125; &#125; &#125;, onConn(item) &#123; console.log(&quot;连接蓝牙---------------&quot; + item.address) &#x2F;* uni.showLoading(&#123; title: &#39;连接中&#39;, mask: false &#125;); *&#x2F; bluetoothTool.connDevice(item.address,(result)&#x3D;&gt;&#123; if(result) &#123; uni.setStorageSync(&#39;lastBleAddress&#39;, item.address) &#125; console.log(&#39;连接结果：&#39;,result) &#125;); &#125;, clickSendData()&#123; let a &#x3D; bluetoothTool.sendData(this.sendData) console.log(a) &#125; &#125; &#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt;","path":"2022/07/21/uniapp的蓝牙模块2/","date":"07-21","excerpt":"","tags":[{"name":"app","slug":"app","permalink":"https://diamond-sjh.github.io/tags/app/"}]},{"title":"蓝牙开发基础","text":"蓝牙开发基础一、基本介绍蓝牙发展至今经历了多个版本的更新，1.1、1.2、2.0、2.1、3.0、4.0、4.1、4.2、5.0等。其中，将1.x~3.0之间的版本称之为经典蓝牙，4.x开始的蓝牙称之为低功耗蓝牙，也就是蓝牙ble。根据应用、协议类型等，可以对蓝牙进行以下分类： 经典蓝牙：顾名思义就是旧版的蓝牙，是Android4.2(API17)版本及以下所使用的蓝牙。使用频率低、低功耗、输入数据量少、传输速度快等，但是有双模式，即普通模式和低功耗模式。普通模式和以前蓝牙（传统蓝牙）一样，可以快速传输较大数据，功耗大。 低功耗蓝牙：也称BLE，是Android4.3(API18)版本及以上所使用的蓝牙，据说相对于经典蓝牙有许多的优势，Google为其提供了新的API。传输大量数据、不考虑功耗、速度、耗电等 二、现在主流是4.0BLE蓝牙 低功耗蓝牙比传统蓝牙，传输速度更快，覆盖范围更广，安全性更高，延迟更短，耗电极低等等优点。 传统的一般通过socket方式，而低功耗蓝牙是通过Gatt协议来实现。 三、经典蓝牙API（ble蓝牙参考uniapp文档）一、建立蓝牙主要有四个步骤 打开蓝牙。 查找附近已配对或可用的设备。 连接设备。 设备间数据交换。 二、配对和连接是一回事？ 配对是指两个设备之间首次建立连接后，系统会自动向用户显示的配对请求，当配对成功后，会自动存储已经配对的设备的信息。 连接就是使用设备存储的MAC地址，即客户端用向存储的MAC地址发起建立 RFCOMM通道的询问，服务端同意后两者的连接就建立起来了。而且利用远程设备的已知MAC地址可以随时向其发起连接(如果在范围内的话)，而无需执行发现操作。所以我们可以得到这几个结论: 配对了不一定连接着。 连接一定要知道对方的蓝牙的MAC地址。 配对只是第一次连接系统为确认安全所做的准备，因此大多数情况下只有一次。 三、所有蓝牙API都在android.bluetooth 包下。下面有一些类和接口的摘要，可能需要它们来建立蓝牙连接: BluetoothAdapter类 代表本地蓝牙适配器（蓝牙无线电）。BluetoothAdapter是所有蓝牙交互的入口。使用这个你可以发现其他蓝牙设备，查询已配对的设备列表，使用一个已知的MAC地址来实例化一个BluetoothDevice，以及创建一个BluetoothServerSocket来为监听与其他设备的通信。 常用的方法有以下几个 getDefaultAdapter() —— 获取默认BluetoothAdapter，实际上，也只有这一种方法获取BluetoothAdapter 12使用说明：1、获取默认本地蓝牙适配器的句柄。目前Android仅支持一个蓝牙适配器，但该API可以扩展为支持更多。 enable() —— 打开蓝牙，这个方法打开蓝牙不会弹出提示，更多的时候我们需要问下用户是否打开，以下这两行代码同样是打开蓝牙，不过会提示用户： 12Intent intent=new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);startActivityForResult(intent,reCode);//同startActivity(intent); reCode定义的请求码 12345使用说明：1、需要 BLUETOOTH_ADMIN权限。2、该方法将不经过用户同意，直接启用底层蓝牙硬件，并启动所有蓝牙系统服务。由于不同Android设备系统的实现不同，所以部分Android系统在调用该方法时也会弹框请求用户同意。3、打开蓝牙，还可以通过调用startActivityForResult方法，使用ACTION_REQUEST_ENABLE意图来实现，此方法将弹出对话框，请求允许打开蓝牙。可以在Activity中的onActivityResult()方法中处理操作结果。4、该方法是一个异步调用：它将立即返回结果。如果此调用返回true，则适配器状态将立即从STATE_OFF转换为STATE_TURNING_ON，并且稍后过渡到STATE_OFF或STATE_ON 。如果此调用返回false，则说明出现问题阻止适配器开启，例如设备处于飞行模式，或者蓝牙已打开。因此还应当监听ACTION_STATE_CHANGED广播，以跟踪后续蓝牙状态更改。 disable() —— 关闭蓝牙 1234使用说明：1、需要 BLUETOOTH_ADMIN权限。2、该方法将不经过用户同意，关闭所有蓝牙连接，停止蓝牙系统服务并关闭底层蓝牙硬件。由于不同Android设备系统的实现不同，所以部分Android系统在调用该方法时也会弹框请求用户同意。3、该方法是一个异步调用：它将立即返回结果。如果此调用返回true，则适配器状态将立即从STATE_ON转换为STATE_TURNING_OFF，并且稍后过渡到STATE_OFF或STATE_ON 。如果此调用返回false，则说明出现问题阻止适配器关闭，例如适配器已关闭。因此还应当监听ACTION_STATE_CHANGED广播，以跟踪后续蓝牙状态更改。 checkBluetoothAddress(String address) —— 验证蓝牙MAC地址 getAddress() —— 获取本地蓝牙地址 getBondedDevices() —— 获取与本机蓝牙所有绑定的远程蓝牙信息 getName() —— 获取本地蓝牙适配器的蓝牙名称 setName(String name) —— 设置本地蓝牙适配器的蓝牙名称 getScanMode() —— 获取本地蓝牙适配器的当前蓝牙扫描模式 蓝牙扫描模式： 名称 值(int) 含义 SCAN_MODE_NONE 20 该设备不能扫描以及被扫描 SCAN_MODE_CONNECTABLE 21 该设备可以扫描其他蓝牙设备 SCAN_MODE_CONNECTABLE_DISCOVERABLE 23 该设备既可以扫描其他设备，也可以被其他设备扫描发现 getState()获取本地蓝牙适配器当前状态（感觉可能调试的时候更需要） 蓝牙适配器状态： 名称 值(int) 含义 STATE_OFF 10 表示本地蓝牙适配器已关闭 STATE_TURNING_ON 11 表示本地蓝牙适配器正在打开 STATE_ON 12 表示本地蓝牙适配器已开启，并可供使用 STATE_TURNING_OFF 13 表示本地蓝牙适配器正在关闭 isEnabled() —— 判断蓝牙是否打开，已打开返回true，否则，返回false。getState()==STATE_ON 等价。 isDiscovering() —— 判断当前是否正在查找设备，是返回true，否则返回false。 1234使用说明：1、需要 BLUETOOTH权限。2、若蓝牙未打开，该方法将返回false。3、扫描设备是一个重量级过程，不应在扫描时尝试建立连接，而此时已存在的蓝牙连接将获得有限制的带宽以及高延迟。 startDiscovery() —— 开始扫描周边蓝牙设备。若启动成功，返回true；否则返回false。 123456使用说明：1、需要 BLUETOOTH_ADMIN权限。2、通常为12秒左右的查询扫描过程。3、这是一个异步调用，它会立即返回。注册ACTION_DISCOVERY_STARTED和ACTION_DISCOVERY_FINISHED广播以确定发现何时开始和完成的确切时间。注册ACTION_FOUND以便在发现远程蓝牙设备时收到通知。4、若蓝牙未打开，该方法将返回false。5、扫描设备是一个重量级过程，不应在扫描时尝试建立连接，而此时已存在的蓝牙连接将获得有限制的带宽以及高延迟。可以使用cancelDiscovery()取消扫描操作。 cancelDiscovery() —— 取消发现，也就是说当我们正在搜索设备的时候调用这个方法将不再继续搜索。取消成功, 则返回true; 如果取消失败, 返回false。 1234使用说明：1、需要 BLUETOOTH_ADMIN权限。2、若蓝牙未打开，该方法将返回false。3、因为蓝牙搜索是一个重量级过程，会耗费大量资源，所以在连接远程蓝牙设备前，必须调用这个方法，取消搜索。 getRemoteDevice(String address) —— 根据蓝牙地址获取远程蓝牙设备。如果MAC无效无效，将抛出IllegalArgumentException异常 listenUsingInsecureRfcommWithServiceRecord(String name,UUID uuid) —— 根据名称，UUID创建一个正在监听的不安全的带有服务记录的无线射频通信（RFCOMM）蓝牙端口并返回BluetoothServerSocket对象 12345使用说明：1、需要 BLUETOOTH权限。2、系统将分配一个未使用的RFCOMM通道进行侦听。3、当发生错误时，例如蓝牙不可用、权限不足、通道被占用等，将抛出IOException异常。4、通过此方式创建的蓝牙服务套接字是不安全的，连接时不需要进行配对。 listenUsingRfcommWithServiceRecord(String name, UUID uuid) —— 根据名称，UUID创建一个正在监听的安全的带有服务记录的无线射频通信（RFCOMM）蓝牙端口并返回BluetoothServerSocket对象 12345使用说明：1、需要 BLUETOOTH权限。2、系统将分配一个未使用的RFCOMM通道进行侦听。3、当发生错误时，例如蓝牙不可用、权限不足、通道被占用等，将抛出IOException异常。4、通过此方式创建的蓝牙服务套接字是安全的，连接时需要进行配对。 BluetoothDevice类 代表一个远程蓝牙设备，使用这个来请求一个与远程设备的BluetoothSocket连接，或者查询关于设备名称、地址、类和连接状态等设备信息。 getName() —— 获取远程蓝牙设备的蓝牙名称。成功则返回蓝牙名称，若出现问题则返回null。 getAddress() —— 获取远程蓝牙设备的硬件地址 getBondState() —— 获取远程蓝牙设备的绑定状态 蓝牙绑定状态： 名称 值(int) 含义 BOND_NONE 10 远程设备未绑定。 BOND_BONDING 11 正在与远程设备进行绑定。 BOND_BONDED 12 远程设备已绑定。 createBond() —— 开始与远程蓝牙设备的绑定过程。若成功开始绑定则返回true，否则返回false。 1234使用说明：1、需要BLUETOOTH_ADMIN权限。2、这是一个异步调用，它会立即返回。注册监听ACTION_BOND_STATE_CHANGED广播，当绑定过程完成时及时获取其结果通知。3、Android系统服务将处理必要的用户交互以确认并完成绑定过程。 createInsecureRfcommSocketToServiceRecord(UUID uuid) —— 根据UUID创建安全的蓝牙套接字并返回一个BluetoothSocket。 123456使用说明：1、需要BLUETOOTH权限。2、通信渠道将不会有认证的链接密钥，即它将受到中间人攻击。3、对于蓝牙 2.1 设备，链接将被加密，因为加密是强制性的。对于旧设备（蓝牙 2.1 之前的设备），链接不会被加密。4、它旨在与listenUsingInsecureRfcommWithServiceRecord(String, UUID)用于对等蓝牙应用。5、出现错误时，例如蓝牙不可用、权限不足，将抛出IOException异常。 createRfcommSocketToServiceRecord(UUID uuid) —— 根据UUID创建安全的蓝牙套接字并返回一个BluetoothSocket 123456使用说明：1、需要BLUETOOTH权限。2、只有经过身份验证的套接字链接才可以使用此套接字。认证是指认证链路密钥，以防止中间人攻击。3、此套接字上的通信将被加密。4、这是为与对等蓝牙应用程序 listenUsingRfcommWithServiceRecord(String, UUID)配合使用而设计的。5、出现错误时，例如蓝牙不可用、权限不足，将抛出IOException异常。 BluetoothServerSocket类 代表一个开放的服务器socket，它监听接受的请求（与TCP ServerSocket类似）。为了连接两台Android设备，一个设备必须使用这个类开启一个服务器socket。当一个远程蓝牙设备开始一个和该设备的连接请求，BluetoothServerSocket将会返回一个已连接的BluetoothSocket，接受该连接。 accept() —— 阻塞直到建立连接（无超时）。成功连接时连接的BluetoothSocket对象。 accept(int timeout) —— 阻塞直到建立连接或超时。成功连接时连接的BluetoothSocket对象 close() —— 关闭该监听服务端口，并释放所有关联的资源。关闭这个端口不会关闭accept()方法返回的BluetoothSocket对象。 BluetoothSocket类 代表一个蓝牙socket的接口（和TCP Socket类似）。这是一个连接点，它允许一个应用与其他蓝牙设备通过InputStream和OutputStream交换数据。 跟BluetoothServerSocket相对，客户端一共5个方法，不出意外，都会用到: connect() —— 尝试连接到远程蓝牙服务器。 isConnected() —— 获取此套接字的连接状态，即是否与远程蓝牙服务连接。若连接则返回true，否则返回false。 getRemoteDevice() —— 获取此套接字连接的远程蓝牙设备返回连接的远程蓝牙设备BluetoothDevice对象。 getInputStream() —— 获取与此套接字关联的输入流返回输入流对象 1234使用说明：1、即使套接字尚未连接，输入流也会返回，但对该流的操作将抛出IOException异常，直到关联的套接字连接。2、该方法调用出错时，将抛出IOException异常。3、通过此方法获取的输入流对象，可以读取对端发送的数据。 getOutputStream() —— 获取与此套接字关联的输出流返回输出流对象 1234使用说明：1、即使套接字尚未连接，输出流也会返回，但对该流的操作将抛出IOException异常，直到关联的套接字连接。2、该方法调用出错时，将抛出IOException异常。3、通过此方法获取的输出流对象，可以发送数据给对端。 close() —— 关闭此流并释放与其关联的所有系统资源。如果流已经关闭，则调用此方法不起作用。该方法调用出现问题，将抛出IOException异常。 BluetoothClass 描述一个蓝牙设备的基本特性和性能。这是一个只读的属性集合，它定义了设备的主要和次要的设备类以及它的服务。但是，它没有描述所有的蓝牙配置和设备支持的服务，它只是暗示了设备的类型。 BluetoothProfile 一个表示蓝牙配置文件的接口。一个Bluetooth profile是一个基于蓝牙的通信无线接口定义。一个例子是Hands-Free profile。更多的讨论请见Working with Profiles。 BluetoothHeadset 提供对移动手机使用的蓝牙耳机的支持。它包含了Headset and Hands-Free (v1.5)配置文件。 BluetoothA2dp 定义高品质的音频如何通过蓝牙连接从一个设备传输到另一个设备。”A2DP“是Advanced Audio Distribution Profile的缩写。 BluetoothHealth 表示一个Health Device Profile代理，它控制蓝牙服务。 BluetoothHealthCallback 一个抽象类，你可以使用它来实现BluetoothHealth的回调函数。你必须扩展这个类并实现回调函数方法来接收应用程序的注册状态改变以及蓝牙串口状态的更新。 BluetoothHealthAppConfiguration 表示一个应用程序配置，Bluetooth Health第三方应用程序注册和一个远程Bluetooth Health设备通信。 BluetoothProfile.ServiceListener 一个接口，当BluetoothProfile IPC客户端从服务器上建立连接或断开连接时，它负责通知它们（也就是，运行在特性配置的内部服务）。 四、连接设备 蓝牙通讯机制建立在socket上； 要在两台设备上创建连接，需要实现**服务器端和客户端**机制 一般通讯过程： 在服务端等待客户端的连接请求， 有连接请求后连接， 连接成功后有一个socket（也即套接字）， 通过socket套接字得到IO流， 往输入流中读数据， 或者往输出流中写数据， 即可以实现两台设备之间的通讯； 服务器设备和客户端设备分别获得需要的BluetoothSocket； 上面说过， 要在两台设备上创建连接， 需要实现服务器端和客户端机制， 其中有一台需要开放服务端的套接字， 另外一台作为客户端， 需要通过蓝牙的Mac地址向服务端发送连接请求； 当我们的服务端和客户端在同一个频道上的话， 就可以进行连接； 之后服务端会接收一个套接字， 这个套接字会作为服务端和客户端 进行通信的接口； 1、设置服务器端设置服务器套接字并接受连接的基本过程： 通过调用listenUsingRfcommWithServiceRecord(String, UUID)获取BluetoothServerSocket； 通过调用accept()开始侦听连接请求 除非要接受更多连接，否则调用close()结束该次通信； 2、设置客户端发起与远程设备（保持开放的服务器套接字的设备）的连接； 首先要获取表示该远程设备的BluetoothDevice对象， 这个对象是通过蓝牙的Mac地址构造的； Mac地址是一个设备的全世界唯一的标识； 通过BluetoothDevice对象 获取BluetoothSocket并发起连接—— 使用BluetoothDevice对象 调用createRfcommSocketToServiceRecord(UUID) 获取BluetoothSocket 通过connect()发起连接； 3、关于BluetoothChatServiceService中包括了三个线程，三个线程分别控制了通信的流程 （左边是Accept Thread，右边是Connect Thread）： ​ AcceptThread函数接收的是一个布尔值secure； 服务端，通过创建ServerSocket来等待客户端的连接， 首先是获取BluetoothSocket： ​ 接着在线程的run()方法中会调用accept()函数，等待客户端的连接： ​ 如果客户端连接成功，if (socket != null)， 则会调用connect()函数，创建一个Connected Thread （注意这里是Connected，不是Connect）， ConnectThread函数接收的是一个布尔值secure，以及一个BluetoothDevice； 通过调用device.createRfcommSocketToServiceRecord()来创建BluetoothSocket； 通过BluetoothSocket的connect()方法就可以连接到服务端： 连接成功后，同样是创建一个Connected Thread； 这个Connected Thread是客户端和服务端共用的； 也即客户端调用connect()之后， 会激活服务端的accept()函数： ​ 激活之后服务端就往下走， Connected Thread 这里， 首先会通过上图中左上（服务端）和右上（客户端）两个构造出来的Socket的传入， 得到两个Stream——input/output Steam；（用于 读/写数据）； 调用write()时会往outputSteam中写东西； 读数据时则处理input stream； ​ 源码： ​ write()： 五、经典蓝牙开发流程1、经典蓝牙开发流程分析 2、蓝牙服务端实现(1)在工程清单文件AndroidManifest.xml中添加权限：123456789101112&lt;!--如果使用了BLUETOOTH_ADMIN权限，那么必须使用BLUETOOTH权限--&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;!--android6.0后需要搜索周边蓝牙设备，需要添加以下两个权限--&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt;&lt;!--设备硬件必须支持蓝牙--&gt;&lt;uses-feature android:name=&quot;android.hardware.bluetooth&quot; android:required=&quot;true&quot;/&gt; (2)获取本地蓝牙适配器：1mBluetoothAdapter= BluetoothAdapter.getDefaultAdapter(); (3)打开蓝牙：123456789101112131415161718192021222324252627282930313233343536/** * 打开蓝牙 * 方式一：通过Intent来向用户弹框请求打开蓝牙，可以重写onActivityResult来监听打开蓝牙的请求结果 */public void openBluetooth()&#123; if(mBluetoothAdapter==null)&#123; showTip(&quot;当前设备不支持蓝牙功能！&quot;); return; &#125; if(mBluetoothAdapter.isEnabled())&#123; showTip(&quot;蓝牙已打开&quot;); return; &#125; Intent intent=new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(intent,GlobalDef.REQ_CODE_OPEN_BT);&#125;@Overridepublic void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if(requestCode==GlobalDef.REQ_CODE_OPEN_BT)&#123; if(resultCode == Activity.RESULT_OK)&#123; showTip(&quot;蓝牙打开成功&quot;); &#125; else&#123; showTip(&quot;蓝牙打开失败&quot;); &#125; &#125;&#125;/** * 打开蓝牙 * 方式二：通过enable方法静默打开蓝牙，无需用户同意（部分Android系统使用该方法依然会弹框提示，向用户请求打开蓝牙） */mBluetoothAdapter.enable(); (4)关闭蓝牙123456789101112131415/** * 关闭蓝牙 */public void closeBluetooth()&#123; if(mBluetoothAdapter==null)&#123; showTip(&quot;当前设备不支持蓝牙功能！&quot;); return; &#125; if(!mBluetoothAdapter.isEnabled())&#123; showTip(&quot;当前蓝牙未打开&quot;); return; &#125; //关闭蓝牙，无需用户同意（部分Android系统使用该方法依然会弹框提示） mBluetoothAdapter.disable();&#125; (5)允许蓝牙可见：12345678910111213141516171819202122232425262728293031323334353637383940414243444546//方式一：通过Intent方式向用户请求允许蓝牙被搜索//注：如果蓝牙没有开启，用户点击确定后，会首先开启蓝牙，继而设置蓝牙能被扫描Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);//设置蓝牙可见性的时间，默认持续时间为120秒，每个请求的最长持续时间上限为300秒intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 120);startActivity(intent);//方式二：通过反射的方式来设置蓝牙可见性，且不会出现弹框//注：如果蓝牙没有开启，通过此方式并不会直接打开蓝牙/** * 设置蓝牙可见 * @param adapter * @param timeout 超时为0时，永久可见 */public static void setDiscoverableTimeout(BluetoothAdapter adapter, int timeout) &#123; //BluetoothAdapter adapter=BluetoothAdapter.getDefaultAdapter(); try &#123; Method setDiscoverableTimeout = BluetoothAdapter.class.getMethod(&quot;setDiscoverableTimeout&quot;, int.class); setDiscoverableTimeout.setAccessible(true); Method setScanMode =BluetoothAdapter.class.getMethod(&quot;setScanMode&quot;, int.class,int.class); setScanMode.setAccessible(true); setDiscoverableTimeout.invoke(adapter, timeout); setScanMode.invoke(adapter, BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE,timeout); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;/** * 关闭蓝牙可见 * @param adapter */public static void closeDiscoverableTimeout(BluetoothAdapter adapter) &#123; try &#123; Method setDiscoverableTimeout = BluetoothAdapter.class.getMethod(&quot;setDiscoverableTimeout&quot;, int.class); setDiscoverableTimeout.setAccessible(true); Method setScanMode =BluetoothAdapter.class.getMethod(&quot;setScanMode&quot;, int.class,int.class); setScanMode.setAccessible(true); setDiscoverableTimeout.invoke(adapter, 1); setScanMode.invoke(adapter, BluetoothAdapter.SCAN_MODE_CONNECTABLE,1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; (6)创建蓝牙服务套接字，等待其他蓝牙客户端连接：12345678910111213141516171819202122232425262728293031323334353637383940/** * 运行服务端 */public void runServer()&#123; if(mServerRunningFlag)&#123; showTip(&quot;服务端正在运行，请勿重复启动!&quot;); return; &#125; try&#123; mSocketList=new LinkedList&lt;BluetoothSocket&gt;(); mExecutorService= Executors.newCachedThreadPool(); mServerSocket=mBluetoothAdapter.listenUsingRfcommWithServiceRecord(&quot;BluetoothTool&quot;, GlobalDef.BT_UUID); mServerSocket=mBluetoothAdapter.listenUsingInsecureRfcommWithServiceRecord(&quot;BluetoothTool&quot;, GlobalDef.BT_UUID); mServerRunningFlag=true; btnServerControl.setText(&quot;关闭服务端&quot;); showTip(&quot;蓝牙服务端成功启动&quot;); new Thread()&#123; @Override public void run()&#123; try&#123; BluetoothSocket socket=null; while(mServerRunningFlag)&#123; socket=mServerSocket.accept(); mSocketList.add(socket); mExecutorService.execute(new SocketThread(socket)); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125;catch(IOException e)&#123; e.printStackTrace(); showTip(&quot;服务端启动出现异常&quot;); Log.e(TAG,&quot;runServer IOException&quot;); &#125;&#125; (7)连接成功之后，就通过获取BluetoothSocket的输入输出流进行数据传输：1234567// 获取流InputStream inputStream = socket.getInputStream();OutputStream outputStream = socket.getOutputStream();// 写出、读入byte[] temp=new byte[1024];inputStream.read(temp);//当无数据时将阻塞等待outputStream.write(temp); (8)以下为用于操作BluetoothSocket的SocketThread的简单实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179class SocketThread extends Thread &#123; private BluetoothSocket mSocket; private BluetoothDevice mDevice; private InputStream mIn; private OutputStream mOut; private boolean isOpen = false; private byte[] mRecBuffer=new byte[1024*10]; private int mRecPos=0; private int mFilePos=0; public SocketThread(BluetoothSocket socket) &#123; try &#123; this.mSocket = socket; mDevice=socket.getRemoteDevice(); mIn = socket.getInputStream(); mOut = socket.getOutputStream(); isOpen = true; showTip(getDevInfo(mDevice)+&quot;成功连接&quot;); Log.d(TAG, &quot;a socket thread create&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); Log.e(TAG, &quot;create SocketThread fail&quot;); &#125; &#125; public String getDevInfo(BluetoothDevice bluetoothDevice)&#123; String strName=&quot;unknown&quot;; String strMac=&quot;unknown&quot;; if(bluetoothDevice!=null)&#123; strName=bluetoothDevice.getName(); strMac=bluetoothDevice.getAddress(); &#125; String info=&quot;[&quot;+strName+&quot;,&quot;+strMac+&quot;]&quot;; return info; &#125; @Override public void run() &#123; int readLen=0; byte[] buffer=new byte[1024]; try&#123; while(isOpen)&#123; readLen=mIn.read(buffer); if(readLen&gt;0)&#123; System.arraycopy(buffer,0,mRecBuffer,mRecPos,readLen); mRecPos+=readLen; while(true)&#123; if(mIn.available()&gt;0)&#123;//若流中有数据，则读取 readLen=mIn.read(buffer); if((mRecPos+readLen)&gt;mRecBuffer.length)&#123;//超出缓冲区 showTip(&quot;读取数据超出缓冲区，将已读取的数据输出：&quot;); showTip(&quot;Receive hex data = &quot;+ StringUtil.bytesToHexString(mRecBuffer,0,mRecPos)); showTip(&quot;Receive string data = &quot;+new String(mRecBuffer,0,mRecPos).trim()); mRecPos=0; Arrays.fill(mRecBuffer,(byte)0x00); &#125; System.arraycopy(buffer,0,mRecBuffer,mRecPos,readLen); mRecPos+=readLen; &#125; else&#123;//若流中无数据 if(mRecPos&gt;0)&#123;//说明此时数据读取完毕，将内容输出 showTip(&quot;Receive hex data = &quot;+StringUtil.bytesToHexString(mRecBuffer,0,mRecPos)); showTip(&quot;Receive string data = &quot;+new String(mRecBuffer,0,mRecPos).trim()); //收到请求文件传输指令 if(mRecBuffer[0]==0x01 &amp;&amp; mRecBuffer[mRecPos-1]==0x04)&#123; String strInfoJson=new String(mRecBuffer,1,mRecPos-2); JSONObject infoJson=new JSONObject(strInfoJson); String fileName=infoJson.getString(&quot;FileName&quot;); long totalSize=infoJson.getLong(&quot;FileSize&quot;);//文件总大小 String fileMD5=infoJson.getString(&quot;MD5&quot;); mFilePos=0;//已传输大小 int nRate=0;//已传输的百分比 File recFile=new File(RECEIVE_FILE_PATH+fileName); if(recFile.exists())&#123; recFile.delete(); &#125; showLoadingDialog(&quot;正在接收文件数据...&quot;+nRate+&quot;%&quot;); //循环接收文件数据并写入文件 while(true)&#123; readLen=mIn.read(buffer); if(readLen&gt;0)&#123; writeFile(fileName,buffer,0,readLen); mFilePos+=readLen; //获得当前百分比 int tmpRate=getPercent(mFilePos,totalSize); if(tmpRate!=nRate)&#123; nRate=tmpRate; showLoadingDialog(&quot;正在接收文件数据...&quot;+nRate+&quot;%&quot;); &#125; if(mFilePos&gt;=totalSize)&#123; break; &#125; &#125; else&#123; break; &#125; &#125; if(!recFile.exists())&#123; showTip(&quot;接收文件失败&quot;); byte[] retData=&quot;Receive file fail!&quot;.getBytes(); writeData(mSocket,retData,0,retData.length); &#125; else&#123; String nMD5= FileDigest.getFileMD5(recFile); if(fileMD5.equals(nMD5))&#123; showTip(&quot;文件接收成功&quot;); byte[] retData=&quot;Server receive file success!&quot;.getBytes(); writeData(mSocket,retData,0,retData.length); &#125; else&#123; showTip(&quot;文件校验失败&quot;); byte[] retData=&quot;File check fail!&quot;.getBytes(); writeData(mSocket,retData,0,retData.length); &#125; &#125; dismissLoadingDialog(); &#125; mRecPos=0; Arrays.fill(mRecBuffer,(byte)0x00); &#125; break; &#125; &#125; &#125; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); dismissLoadingDialog(); release(); &#125; &#125; public void release()&#123; Log.d(TAG,&quot;A socketThread release&quot;); try&#123; if(isOpen)&#123; showTip(getDevInfo(mDevice)+&quot;断开连接&quot;); &#125; isOpen=false; if(mOut!=null)&#123; try&#123; mOut.close(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; mOut=null; &#125; if(mIn!=null)&#123; try&#123; mIn.close(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; mIn=null; &#125; if(mSocket!=null)&#123; mSocketList.remove(mSocket); try&#123; mSocket.close(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; mSocket=null; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 3、蓝牙客户端实现(1)添加权限，同蓝牙服务端。(2)获取本地蓝牙适配器，同蓝牙服务端。(3)打开蓝牙，同蓝牙服务端。(4)关闭蓝牙，同蓝牙服务端。(5)允许蓝牙可见，同蓝牙服务端。(6)定义蓝牙广播接收器，用于接收蓝牙搜索、连接状态改变等的广播：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class BluetoothBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent)&#123; String action=intent.getAction(); Log.d(TAG,&quot;Action received is &quot;+action); //蓝牙搜索 if(BluetoothDevice.ACTION_FOUND.equals(action))&#123; BluetoothDevice scanDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); if(scanDevice == null || scanDevice.getName() == null)&#123; return; &#125; int btType=scanDevice.getType(); if(btType==BluetoothDevice.DEVICE_TYPE_LE || btType==BluetoothDevice.DEVICE_TYPE_UNKNOWN)&#123; return; &#125; Log.d(TAG, &quot;bt name=&quot;+scanDevice.getName()+&quot; address=&quot;+scanDevice.getAddress()); deviceList.add(scanDevice); short rssi=intent.getExtras().getShort(BluetoothDevice.EXTRA_RSSI); rssiList.add(rssi); listAdapter.notifyDataSetChanged(); &#125; //蓝牙配对 else if(BluetoothDevice.ACTION_BOND_STATE_CHANGED.equals(action))&#123; BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); if(mCurDevice!=null &amp;&amp; btDevice.getAddress().equals(mCurDevice.getAddress()))&#123; int state = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, -1); if(state==BluetoothDevice.BOND_NONE)&#123; showTip(&quot;已取消与设备&quot; + btDevice.getName() + &quot;的配对&quot;); mFlag=-1; &#125; else if(state==BluetoothDevice.BOND_BONDED)&#123; showTip(&quot;与设备&quot; + btDevice.getName() + &quot;配对成功&quot;); mFlag=1; &#125; &#125; &#125; else if(BluetoothAdapter.ACTION_STATE_CHANGED.equals(action))&#123; int blueState = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, 0); switch (blueState) &#123; case BluetoothAdapter.STATE_TURNING_ON: Log.i(TAG,&quot;onReceive---------STATE_TURNING_ON&quot;); break; case BluetoothAdapter.STATE_ON: Log.i(TAG,&quot;onReceive---------STATE_ON&quot;); showTip(&quot;蓝牙当前状态：ON&quot;); break; case BluetoothAdapter.STATE_TURNING_OFF: Log.i(TAG,&quot;onReceive---------STATE_TURNING_OFF&quot;); break; case BluetoothAdapter.STATE_OFF: Log.i(TAG,&quot;onReceive---------STATE_OFF&quot;); showTip(&quot;蓝牙当前状态：OFF&quot;); break; &#125; &#125; &#125;&#125; (7)注册广播：1234567891011121314151617@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_client); mContext=this; mBluetoothAdapter= BluetoothAdapter.getDefaultAdapter(); initView(); loadingDialog=new LoadingDialog(mContext); //注册广播 mBluetoothBroadcastReceiver=new BluetoothBroadcastReceiver(); IntentFilter filter=new IntentFilter(); filter.addAction(BluetoothDevice.ACTION_FOUND); filter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED); filter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED); mContext.registerReceiver(mBluetoothBroadcastReceiver,filter);&#125; (8)搜索周边蓝牙设备：12345if(mBluetoothAdapter.isDiscovering())&#123; mBluetoothAdapter.cancelDiscovery();&#125;//搜索到的蓝牙设备通过广播接收mBluetoothAdapter.startDiscovery(); (9)建立与蓝牙服务器的连接：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 蓝牙配对并连接 */public void bondAndConnect()&#123; //取消搜索 if(mBluetoothAdapter.isDiscovering())&#123; mBluetoothAdapter.cancelDiscovery(); &#125; if(mCurDevice==null)&#123; showTip(&quot;远程蓝牙设备为空！&quot;); return; &#125; //当前蓝牙设备未配对，则先进行配对 if(mCurDevice.getBondState()==BluetoothDevice.BOND_NONE)&#123; Log.d(TAG,&quot;create bond to &quot;+mCurDevice.getName()); boolean nRet= BluetoothUtil.createBond(mCurDevice); if(!nRet)&#123; showTip(&quot;createBond fail！&quot;); return; &#125; showLoadingDialog(&quot;正在与【&quot;+mCurDevice.getName()+&quot;】进行配对...&quot;); mFlag=0; while(mFlag==0)&#123; SystemClock.sleep(250); &#125; if(mFlag==-1)&#123; showTip(&quot;与【&quot;+mCurDevice.getName()+&quot;】的蓝牙配对失败&quot;); dismissLoadingDialog(); return; &#125; &#125; if(mCurDevice.getBondState()==BluetoothDevice.BOND_BONDED)&#123; showLoadingDialog(&quot;正在与【&quot;+mCurDevice.getName()+&quot;】进行连接...&quot;); try &#123; //创建Socket BluetoothSocket socket = mCurDevice.createRfcommSocketToServiceRecord(GlobalDef.BT_UUID); //启动连接线程 socket.connect(); mThread=new SocketThread(socket); mThread.start(); showTip((&quot;成功与【&quot;+mCurDevice.getName()+&quot;】建立连接&quot;)); &#125; catch (IOException e) &#123; Log.d(TAG,&quot;socket connect fail&quot;); showTip((&quot;连接【&quot;+mCurDevice.getName()+&quot;】失败&quot;)); e.printStackTrace(); &#125; &#125; dismissLoadingDialog();&#125; (10)连接成功之后，就通过输入输出流进行数据传输，同蓝牙服务端。GitHub地址：https://github.com/Diamond-sjh/Bluetooth","path":"2022/07/21/蓝牙开发/","date":"07-21","excerpt":"","tags":[{"name":"app","slug":"app","permalink":"https://diamond-sjh.github.io/tags/app/"}]},{"title":"unipush的蓝牙模块","text":"unipush的蓝牙模块一、蓝牙模块初始化这里主要目的就是检测一下手机蓝牙是否打开 方法一 123456789101112131415161718192021// 蓝牙初始化getBluetoot()&#123; // HTML5+ API打开初始化蓝牙 plus.bluetooth.openBluetoothAdapter(&#123; success:(res)=&gt; &#123; //蓝牙已打开 uni.getBluetoothAdapterState(&#123;//蓝牙的匹配状态 success:(res1)=&gt;&#123; console.log(res1,&#x27;本机设备的蓝牙已打开&#x27;) // 获取已配对蓝牙列表 this.bluetooth_list() &#125;, fail(error) &#123; uni.showToast(&#123;icon:&#x27;none&#x27;,title: &#x27;查看手机蓝牙是否打开&#x27;&#125;) &#125; &#125;) &#125;, fail:err=&gt;&#123; // 蓝牙未打开 console.log(&#x27;open failed: &#x27;+JSON.stringify(e)); &#125; &#125;)&#125;, 方法二 123456789101112131415161718uni.openBluetoothAdapter(&#123; success:(res)=&gt; &#123; //已打开 uni.getBluetoothAdapterState(&#123;//蓝牙的匹配状态 success:(res1)=&gt;&#123; console.log(res1,&#x27;“本机设备的蓝牙已打开”&#x27;) // 开始搜索蓝牙设备 this.startBluetoothDeviceDiscovery() &#125;, fail(error) &#123; uni.showToast(&#123;icon:&#x27;none&#x27;,title: &#x27;查看手机蓝牙是否打开&#x27; &#125; &#125;); &#125;, fail:err=&gt;&#123; //未打开 uni.showToast(&#123;icon:&#x27;none&#x27;,title: &#x27;查看手机蓝牙是否打开&#x27;&#125;); &#125;&#125;) 二、打开蓝牙参考链接地址：https://www.jianshu.com/p/0b2f01a576fa 12345678910111213141516171819openPhoneBluetooth()&#123; let main, BluetoothAdapter, BAdapter; switch(uni.getSystemInfoSync().platform)&#123; case &#x27;android&#x27;: main = plus.android.runtimeMainActivity(); BluetoothAdapter = plus.android.importClass(&quot;android.bluetooth.BluetoothAdapter&quot;); BAdapter = BluetoothAdapter.getDefaultAdapter(); if(!BAdapter.isEnabled()) &#123; BAdapter.enable(); &#125; break; case &#x27;ios&#x27;: console.log(&#x27;运行在ios上&#x27;) break; default: console.log(&#x27;运行在开发者工具上&#x27;) break; &#125; &#125;, 三、获取蓝牙列表重点就是获取到了 deviceId 这是连接蓝牙的重要ID，存起来后面我们会用到把获取到的蓝牙列表存起来，方便页面展示，选择蓝牙连接 获取已经配对的蓝牙列表 12345678910111213141516171819// 获取已配对蓝牙列表bluetooth_list() &#123; var main = plus.android.runtimeMainActivity(); var BluetoothAdapter = plus.android.importClass(&quot;android.bluetooth.BluetoothAdapter&quot;); var BAdapter = BluetoothAdapter.getDefaultAdapter(); var Context = plus.android.importClass(&quot;android.content.Context&quot;); var lists = BAdapter.getBondedDevices(); plus.android.importClass(lists); var len = lists.size(); var iterator = lists.iterator(); plus.android.importClass(iterator); let bluetoothList = [] while (iterator.hasNext()) &#123; var d = iterator.next(); plus.android.importClass(d); // 获取的已配对蓝牙名称和地址 存起来 bluetoothList.push(&#123;name:d.getName(),deviceId:d.getAddress(),connect:false&#125;) &#125; &#125;, 获取附近蓝牙设备 12345678910111213141516171819// 开始搜索蓝牙设备startBluetoothDeviceDiscovery()&#123; uni.startBluetoothDevicesDiscovery(&#123; success: (res) =&gt; &#123; console.log(&#x27;startBluetoothDevicesDiscovery success&#x27;, res) // 发现外围设备 // 监听搜索到新设备事件 uni.onBluetoothDeviceFound((res) =&gt; &#123; // [&quot;name&quot;, &quot;deviceId&quot;] // 把搜索到的设备存储起来，方便我们在页面上展示 if(this.list.indexOf(res.devices[0].deviceId)==-1)&#123; this.list.push(res.devices[0].deviceId) &#125; &#125;) &#125;,fail:err=&gt;&#123; console.log(err,&#x27;错误信息&#x27;) &#125; &#125;)&#125; 四、点击选择自己需要连接的蓝牙设备把连接蓝牙的 deviceId 存起来后面我们会用到 方法一（连接已配对的蓝牙设备，不需要停止蓝牙搜索，因为不会一直搜索附近蓝牙） 123456789101112131415161718192021222324// 点击蓝牙连接(选择设备把deviceId传进来)connetBlue(item) &#123; let that = this //data里面建立一个deviceId，存储起来 this.deviceId = item.deviceId uni.createBLEConnection(&#123; // 这里的 deviceId 需要已经通过 createBLEConnection 与对应设备建立链接 deviceId: item.deviceId, //设备id success: (res) =&gt; &#123; // 蓝牙连接成功 uni.onBLEConnectionStateChange(function (res) &#123; // 该方法回调中可以用于处理连接意外断开等异常情况 console.log(res) &#125;) //获取蓝牙设备的所有服务 //注：这个地方使用了setTimeout等待一秒种再去获取，直接获取我们可能出现获取不到的情况。 setTimeout(()=&gt;&#123; that.getBLEDeviceServices(that.deviceId); &#125;,1500) &#125;, fail: (res) =&gt; &#123; // 蓝牙连接失败 console.log(res) &#125;, &#125;)&#125;, 方法二 1234567891011121314151617181920212223242526272829//选择设备连接吧deviceId传进来createBLEConnection(deviceId)&#123; let thit = this //data里面建立一个deviceId，存储起来 this.deviceId = deviceId //连接蓝牙 uni.createBLEConnection(&#123; // 这里的 deviceId 需要已经通过 createBLEConnection 与对应设备建立链接 deviceId:this.deviceId, success(res) &#123; // 蓝牙连接成功停止搜索 uni.stopBluetoothDevicesDiscovery(&#123; success: e =&gt; &#123; this.loading = false console.log(&#x27;停止搜索蓝牙设备:&#x27; + e.errMsg); &#125;, fail: e =&gt; &#123; console.log(&#x27;停止搜索蓝牙设备失败，错误码：&#x27; + e.errCode); &#125; &#125;); // 获取已连接蓝牙的所有服务 that.getBLEDeviceServices(); &#125;,fail(res) &#123; console.log(&quot;蓝牙连接失败&quot;,res) &#125; &#125;)&#125;, 五、获取已连接蓝牙的所有服务把服务列表和需要用到的服务uuid（serviceId）存储起来，后面我们会用到 注：这个地方使用了setTimeout等待一秒种再去获取，直接获取我们可能出现获取不到的情况 方法一(此方法在调用的时候做了延迟，故不需要再次加定时器) 1234567891011121314151617// 获取服务列表getBLEDeviceServices(deviceId) &#123; uni.getBLEDeviceServices(&#123; // 这里的 deviceId 需要已经通过 createBLEConnection 与对应设备建立链接 deviceId: deviceId, success: (res) =&gt; &#123; if(res.services &amp;&amp; res.services.length &gt; 0)&#123; this.serverList = res.services // 所有的服务 this.serviceId = res.services[3].uuid // 存储所需求的服务对应的uuid this.getBLEDeviceCharacteristics() //获取特征值 &#125; &#125;, fail: function(res) &#123; console.log(res) &#125;, &#125;)&#125;, 方法二 1234567891011121314151617181920//获取蓝牙的所有服务getBLEDeviceServices()&#123; // 使用了setTimeout等待一秒种再去获取，直接获取我们可能出现获取不到的情况** setTimeout(()=&gt;&#123; uni.getBLEDeviceServices(&#123; // 这里的 deviceId 需要已经通过 createBLEConnection 与对应设备建立链接 deviceId:this.deviceId, success:(res)=&gt;&#123; //这里会获取到好多个services uuid 我们只存储我们需要用到的就行，这个uuid一般硬件厂家会给我们提供 if(res.services &amp;&amp; res.services.length &gt; 0)&#123; this.serverList = res.services // 所有的服务 this.serviceId = res.services[3].uuid // 存储所需求的服务对应的uuid this.getBLEDeviceCharacteristics() //获取特征值 &#125; &#125; &#125;) &#125;,1000)&#125;, 六、获取蓝牙特征值这里需要穿2个参数了，就是上面的两个id，分别是deviceId、services这里获取的特征值的uuid才是我们真正需要操作的uuid 方法一 123456789101112131415161718192021// 获取特征值 getBLEDeviceCharacteristics() &#123; uni.getBLEDeviceCharacteristics(&#123; // 这里的 deviceId 需要已经通过 createBLEConnection 与对应设备建立链接 deviceId: this.deviceId, // 这里的 serviceId 需要在上面的 getBLEDeviceServices 接口中获取 serviceId: this.serviceId, success: (res) =&gt; &#123; console.log(res) if(res.characteristics &amp;&amp; res.characteristics.length &gt; 0)&#123; this.characteristics = res.characteristics //服务serviceId对应的所有特征值 this.notifyUUid = res.characteristics[2].uuid //需要用到读取数据 特征值uuid（根据自己需求） this.writeUUid = res.characteristics[3].uuid //需要用到写入数据 特征值uuid（根据自己需求） this.notifyBLECharacteristicValueChange()// 启用蓝牙特征值变化时的 notify 功能 &#125; &#125;, fail: function(res) &#123; console.log(res) &#125;, &#125;) &#125;, 方法二 123456789101112131415161718192021222324//获取蓝牙特征getBLEDeviceCharacteristics()&#123; console.log(&quot;进入特征&quot;); setTimeout(()=&gt;&#123; uni.getBLEDeviceCharacteristics(&#123; // 这里的 deviceId 需要已经通过 createBLEConnection 与对应设备建立链接 deviceId:this.deviceId, // 这里的 serviceId 需要在 getBLEDeviceServices 接口中获取 serviceId:this.serviceId, success:(res)=&gt;&#123; if(res.characteristics &amp;&amp; res.characteristics.length &gt; 0)&#123; this.characteristics = res.characteristics //服务serviceId对应的所有特征值 this.notifyUUid = res.characteristics[2].uuid //需要用到读取数据 特征值uuid（根据自己需求） this.writeUUid = res.characteristics[3].uuid //需要用到写入数据 特征值uuid（根据自己需求） this.notifyBLECharacteristicValueChange() // 启用蓝牙特征值变化时的 notify 功能 &#125; &#125;, fail:(res)=&gt;&#123; console.log(res) &#125; &#125;) &#125;,1000)&#125; 七、启用蓝牙设备特征值变化时的 notify 功能123456789101112131415161718192021notifyBLECharacteristicValueChange() &#123; uni.notifyBLECharacteristicValueChange(&#123; deviceId:this.deviceId,//设备uuid serviceId:this.serviceId,//服务对应的uuid characteristicId:this.notifyUUid,//监听的特征值uuid state:true, success: (res) =&gt; &#123; console.log(&quot;广播开启成功----&quot; + bluetoothInfo.notifyUUid) //监听特征值的变化 this.onBLECharacteristicValueChange(); &#125;, fail: (err) =&gt; &#123; console.error(err) uni.showToast(&#123; title: &#x27;蓝牙连接异常&#x27;, icon: &#x27;error&#x27;, duration: 2000 &#125;); &#125; &#125;) &#125;, 八、监听蓝牙设备的特征值变化12345678910111213141516171819// 监听低功耗蓝牙设备的特征值变化（callback是返回触发的方法，根据需求） onBLECharacteristicValueChange(callback) &#123; let macValue = &#x27;&#x27; let timer = null uni.onBLECharacteristicValueChange((res) =&gt; &#123; macValue = macValue + this.ab2str(res.value);//处理得到的返回值 //防抖处理，防止同一个数据多次返回（可不要） if(timer)&#123; clearTimeout(timer) timer = null &#125;else&#123; timer = setTimeout(() =&gt; &#123; callback(macValue) clearTimeout(timer) timer = null &#125;,1000) &#125; &#125;) &#125;, 九、写入数据123456789101112131415161718192021write() &#123; clearTimeout(timer1) timer1 = null // str2ab 处理字符串为设备可接受的ArrayBuffer对象 let buffer = this.str2ab(&#x27;Ed&#x27;) plus.bluetooth.writeBLECharacteristicValue(&#123; deviceId: this.deviceId, serviceId: this.serviceId, characteristicId: this.writeUUid, writeType: &#x27;writeNoResponse&#x27;, value: buffer, success: (res) =&gt; &#123; //此时设备已接收到你写入的数据 console.log(&quot;写入成功---&quot; + bluetoothInfo.writeUUid) macValue = &#x27;&#x27; &#125;, fail: (err) =&gt; &#123; console.log(err) &#125; &#125;) &#125;, 分包发送（是否使用看具体情况，方法待验证） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* 执行演示分包操作 */ writeDevice(_Buffer)&#123; let Num = 0; let ByteLength = _Buffer.byteLength; let i = 1; while (ByteLength &gt; 0) &#123; i++; let TmpBuffer; if(ByteLength &gt; 20)&#123; TmpBuffer = _Buffer.slice(Num, Num + 20); Num += 20; ByteLength -= 20; console.log(&#x27;执行常规循环&#x27;) uTool.delayed(500).then(()=&gt;&#123; uni.writeBLECharacteristicValue(&#123; deviceId:self.mDeviceId, serviceId:self.serviceId, characteristicId:self.characteristicId, value: TmpBuffer, success: (res) =&gt; &#123; /* 发送成功 */ console.log(&#x27;前面的循环成功&#x27;, res) &#125;, fail: (error) =&gt; &#123; /* 发送失败 */ console.log(&#x27;前面的循环失败&#x27;,error) &#125; &#125;) &#125;) &#125;else&#123; console.log(&#x27;执行最后一次&#x27;) TmpBuffer = _Buffer.slice(Num, Num + ByteLength) Num += ByteLength ByteLength -= ByteLength /* 当长度不满20的时候执行最后一次发送即可 */ uni.writeBLECharacteristicValue(&#123; deviceId:self.mDeviceId, serviceId:self.serviceId, characteristicId:self.characteristicId, value: TmpBuffer, success: (res) =&gt; &#123; /* 发送成功 */ console.log(&#x27;最后一次写入成功&#x27;, res) &#125;, fail: (error) =&gt; &#123; /* 发送失败 */ console.log(&#x27;最后一次写入失败&#x27;,error) &#125; &#125;) &#125; &#125; &#125; &#125; 十、方法函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//arraybuffer 转字符串 参数为ArrayBuffer对象 ab2str(str) &#123; // ArrayBuffer转16进度字符串示例 function ab2hex(buffer) &#123; const hexArr = Array.prototype.map.call( new Uint8Array(buffer), function(bit) &#123; return (&#x27;00&#x27; + bit.toString(16)).slice(-2) &#125; ) return hexArr.join(&#x27;&#x27;) &#125; //16进制 let systemStr = ab2hex(str) function hexCharCodeToStr(hexCharCodeStr) &#123; var trimedStr = hexCharCodeStr.trim(); var rawStr = trimedStr.substr(0, 2).toLowerCase() === &quot;0x&quot; ? trimedStr.substr(2) : trimedStr; var len = rawStr.length; if (len % 2 !== 0) &#123; alert(&quot;Illegal Format ASCII Code!&quot;); return &quot;&quot;; &#125; var curCharCode; var resultStr = []; for (var i = 0; i &lt; len; i = i + 2) &#123; curCharCode = parseInt(rawStr.substr(i, 2), 16); // ASCII Code Value let str5 = String.fromCharCode(curCharCode) if (str5.startsWith(&#x27;\\n&#x27;) == false) &#123; resultStr.push(String.fromCharCode(curCharCode)); &#125; &#125; return resultStr.join(&quot;&quot;); &#125; return hexCharCodeToStr(systemStr) &#125;, // 字符串转为ArrayBuffer对象，参数为字符串 str2ab(str) &#123; // 创建一个固定长度的二进制缓冲区 二进制ArrayBuffer对象 let buffer = new ArrayBuffer(str.length*2); // 在Unicode编码方案中，一个英文字符或一个汉字字符都占用两个字节的空间 // 操作二进制ArrayBuffer对象 let dataView = new DataView(buffer) for (var i=0, strLen = str.length; i&lt;strLen; i++) &#123; // 设置占8-bit的字节数组 一个字节 16进制数据 dataView.setUint8(i, parseInt((str.charCodeAt(i)).toString(16),16) ) // dataView.setUint8(i, &#x27;0X&#x27; + value.substring(i * 2, i * 2 + 2)); 错误写法 ：需要16进制数字类型 不能字符串 &#125; return buffer; &#125;, 十一、完整代码vue页面代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227&lt;template&gt; &lt;view class&#x3D;&quot;wrap&quot;&gt; &lt;u-cell-group&gt; &lt;u-cell-item v-for&#x3D;&quot;(item,index) in bluetoothList&quot; :key&#x3D;&quot;index&quot; :arrow&#x3D;&quot;false&quot; :title&#x3D;&quot;item.name&quot;&gt; &lt;u-button slot&#x3D;&quot;right-icon&quot; type&#x3D;&quot;warning&quot; @click&#x3D;&quot;connetBlue(item)&quot;&gt;&#123;&#123;item.connect?&#39;断开连接&#39;:&#39;连接&#39;&#125;&#125;&lt;&#x2F;u-button&gt; &lt;&#x2F;u-cell-item&gt; &lt;&#x2F;u-cell-group&gt; &lt;u-button type&#x3D;&quot;success&quot; @click&#x3D;&quot;autoMeasure&quot;&gt;自动测量&lt;&#x2F;u-button&gt; &lt;!-- 消息提示 --&gt; &lt;u-toast ref&#x3D;&quot;uToast&quot; &#x2F;&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; import &#123; mapActions,mapGetters &#125; from &#39;vuex&#39; import utils from &#39;.&#x2F;common&#x2F;utils.js&#39; var that export default&#123; data() &#123; return &#123; connectBluetooth:&#123;&#125;, bluetoothList: [], &#x2F;&#x2F; 蓝牙设备列表 deviceId: &quot;&quot;, &#x2F;&#x2F; 要连接蓝牙设备id bluetoothName:&#39;&#39;,&#x2F;&#x2F; 要连接蓝牙设备name serverList: [], &#x2F;&#x2F; 连接蓝牙设备的服务数据 serviceId: &quot;&quot;, &#x2F;&#x2F; 连接蓝牙设备的服务id characteristics: [], &#x2F;&#x2F; 连接蓝牙设备的特征值数据 notifyUUid:&#39;&#39;, writeUUid:&#39;&#39;, &#125;; &#125;, onLoad()&#123; &#x2F;&#x2F; 获取eventChannel事件 const eventChannel &#x3D; this.getOpenerEventChannel() eventChannel.on(&#39;toBluetooth&#39;, (val) &#x3D;&gt; &#123; this.connectBluetooth &#x3D; Object.assign(this.connectBluetooth,val) this.getBluetoot() &#125;) that &#x3D; this &#125;, computed: &#123; ...mapGetters([&#39;getBluetoothInfo&#39;]), &#125;, methods:&#123; ...mapActions([&#39;setBluetoothInfo&#39;]), &#x2F;&#x2F; 蓝牙初始化 getBluetoot()&#123; plus.bluetooth.openBluetoothAdapter(&#123; success:(e) &#x3D;&gt; &#123; console.log(&#39;初始化成功&#39;); this.bluetooth_list() &#125;, fail:(e) &#x3D;&gt; &#123; console.log(&#39;open failed: &#39;+JSON.stringify(e)); &#125; &#125;); &#125;, &#x2F;&#x2F; 获取已配对蓝牙列表 bluetooth_list() &#123; var main &#x3D; plus.android.runtimeMainActivity(); var BluetoothAdapter &#x3D; plus.android.importClass(&quot;android.bluetooth.BluetoothAdapter&quot;); var BAdapter &#x3D; BluetoothAdapter.getDefaultAdapter(); var Context &#x3D; plus.android.importClass(&quot;android.content.Context&quot;); var lists &#x3D; BAdapter.getBondedDevices(); plus.android.importClass(lists); var len &#x3D; lists.size(); var iterator &#x3D; lists.iterator(); plus.android.importClass(iterator); let bluetoothList &#x3D; [] while (iterator.hasNext()) &#123; var d &#x3D; iterator.next(); plus.android.importClass(d); bluetoothList.push(&#123;name:d.getName(),deviceId:d.getAddress(),connect:false&#125;) &#125; bluetoothList.forEach((val) &#x3D;&gt; &#123; if(val.name &#x3D;&#x3D; that.connectBluetooth.blueName &amp;&amp; val.deviceId &#x3D;&#x3D; that.connectBluetooth.deviceId)&#123; val.connect &#x3D; true &#125; &#125;) that.bluetoothList &#x3D; bluetoothList &#125;, &#x2F;&#x2F; 点击蓝牙连接 connetBlue(item) &#123; this.deviceId &#x3D; item.deviceId this.bluetoothName &#x3D; item.name if(this.connectBluetooth &amp;&amp; this.connectBluetooth.deviceId)&#123; if(!item.connect)&#123; that.$refs.uToast.show(&#123; title: &#39;请先断开连接&#39;, type: &#39;error&#39;, duration: 800 &#125;) &#125;else&#123; this.stop(this.connectBluetooth.deviceId,item) &#125; &#125;else&#123; createBLEConnection(item.deviceId) &#125; function createBLEConnection(deviceId)&#123; uni.createBLEConnection(&#123; &#x2F;&#x2F; 这里的 deviceId 需要已经通过 createBLEConnection 与对应设备建立链接 deviceId: deviceId, &#x2F;&#x2F;设备id success: (res) &#x3D;&gt; &#123; uni.onBLEConnectionStateChange(function (res) &#123; &#x2F;&#x2F; 该方法回调中可以用于处理连接意外断开等异常情况 console.log(res) &#125;) item.connect &#x3D; true &#x2F;&#x2F;获取蓝牙服务 setTimeout(()&#x3D;&gt;&#123; that.getBLEDeviceServices(that.deviceId); &#125;,1500) &#125;, fail: (res) &#x3D;&gt; &#123; console.log(res) &#125;, &#125;) &#125; &#125;, &#x2F;&#x2F; 获取服务列表 getBLEDeviceServices(deviceId) &#123; uni.getBLEDeviceServices(&#123; &#x2F;&#x2F; 这里的 deviceId 需要已经通过 createBLEConnection 与对应设备建立链接 deviceId: deviceId, success: (res) &#x3D;&gt; &#123; if(res.services &amp;&amp; res.services.length &gt; 0)&#123; this.serverList &#x3D; res.services this.serviceId &#x3D; res.services[3].uuid this.getBLEDeviceCharacteristics() &#x2F;&#x2F;6.0 &#125; &#125;, fail: function(res) &#123; console.log(res) &#125;, &#125;) &#125;, &#x2F;&#x2F; 获取特征值 getBLEDeviceCharacteristics() &#123; uni.getBLEDeviceCharacteristics(&#123; &#x2F;&#x2F; 这里的 deviceId 需要已经通过 createBLEConnection 与对应设备建立链接 deviceId: this.deviceId, &#x2F;&#x2F; 这里的 serviceId 需要在上面的 getBLEDeviceServices 接口中获取 serviceId: this.serviceId, success: (res) &#x3D;&gt; &#123; console.log(res) if(res.characteristics &amp;&amp; res.characteristics.length &gt; 0)&#123; this.characteristics &#x3D; res.characteristics this.notifyUUid &#x3D; res.characteristics[2].uuid this.writeUUid &#x3D; res.characteristics[3].uuid this.setBluetoothInfo(&#123; data:&#123; deviceId: this.deviceId, bluetoothName: this.bluetoothName, serviceId: this.serviceId, characteristicId: this.characteristics, notifyUUid:this.notifyUUid, writeUUid:this.writeUUid &#125;, callback:this.backFunction &#125;) &#125; &#125;, fail: function(res) &#123; console.log(res) &#125;, &#125;) &#125;, &#x2F;&#x2F; 蓝牙数据保存成功的回调 backFunction()&#123; let a &#x3D; this.getBluetoothInfo console.log(a) const eventChannel &#x3D; this.getOpenerEventChannel(); eventChannel.emit(&#39;bluetoothToIndex&#39;); this.$refs.uToast.show(&#123; title: &#39;蓝牙连接成功&#39;, type: &#39;success&#39;, back: true, duration: 800 &#125;) &#125;, &#x2F;&#x2F; 点击测量按钮 autoMeasure()&#123; utils.notifyBLECharacteristicValueChange(this.receiveData) &#125;, &#x2F;&#x2F; 接收测量数据 receiveData(res)&#123; console.log(res.split(&#39;,&#39;)) let data &#x3D; (res.replace(&#x2F;[\\r\\n]&#x2F;g,&quot;&quot;)).split(&#39;,&#39;) &#125;, &#x2F;&#x2F; 断开连接 stop(deviceId,connectDevice)&#123; uni.closeBLEConnection(&#123; deviceId:deviceId, success(res) &#123; that.$refs.uToast.show(&#123; title: &#39;断开连接成功&#39;, type: &#39;success&#39;, duration: 800 &#125;) that.setBluetoothInfo(&#123; data:&#123; deviceId: &#39;&#39;, bluetoothName: &#39;&#39;, serviceId: &#39;&#39;, characteristicId: &#39;&#39;, notifyUUid:&#39;&#39;, writeUUid:&#39;&#39; &#125;, &#125;) connectDevice.connect &#x3D; false that.connectBluetooth &#x3D; &#123;&#125; &#125; &#125;) &#125; &#125; &#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt; utils代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140import store from &#x27;../store/index.js&#x27;;let macValue;let bluetoothInfo = store.state.bluetooth;let timer = nulllet timer1 = nullexport default &#123; // 打开蓝牙 openPhoneBluetooth()&#123; let main, BluetoothAdapter, BAdapter; switch(uni.getSystemInfoSync().platform)&#123; case &#x27;android&#x27;: main = plus.android.runtimeMainActivity(); BluetoothAdapter = plus.android.importClass(&quot;android.bluetooth.BluetoothAdapter&quot;); BAdapter = BluetoothAdapter.getDefaultAdapter(); if(!BAdapter.isEnabled()) &#123; BAdapter.enable(); &#125; break; case &#x27;ios&#x27;: console.log(&#x27;运行在ios上&#x27;) break; default: console.log(&#x27;运行在开发者工具上&#x27;) break; &#125; &#125;, // 启用 notify 功能 notifyBLECharacteristicValueChange(callback) &#123; uni.notifyBLECharacteristicValueChange(&#123; deviceId:bluetoothInfo.deviceId, serviceId:bluetoothInfo.serviceId, characteristicId:bluetoothInfo.notifyUUid, state:true, success: (res) =&gt; &#123; console.log(&quot;广播开启成功----&quot; + bluetoothInfo.notifyUUid) this.onBLECharacteristicValueChange(callback); &#125;, fail: (err) =&gt; &#123; console.error(err) uni.showToast(&#123; title: &#x27;蓝牙连接异常&#x27;, icon: &#x27;error&#x27;, duration: 2000 &#125;); &#125; &#125;) &#125;, // 监听低功耗蓝牙设备的特征值变化 onBLECharacteristicValueChange(callback) &#123; console.log(&#x27;onBLECharacteristicValueChange&#x27;) uni.onBLECharacteristicValueChange((res) =&gt; &#123; macValue = macValue + this.ab2str(res.value); console.log(macValue) if(timer)&#123; clearTimeout(timer) timer = null &#125;else&#123; timer = setTimeout(() =&gt; &#123; callback(macValue) clearTimeout(timer) timer = null &#125;,1000) &#125; &#125;) timer1 = setTimeout(() =&gt; &#123; this.write() &#125;,1000) &#125;, write() &#123; console.log(&#x27;write&#x27;) clearTimeout(timer1) timer1 = null let buffer = this.str2ab(&#x27;Ed&#x27;) plus.bluetooth.writeBLECharacteristicValue(&#123; deviceId: bluetoothInfo.deviceId, serviceId: bluetoothInfo.serviceId, characteristicId: bluetoothInfo.writeUUid, writeType: &#x27;writeNoResponse&#x27;, value: buffer, success: (res) =&gt; &#123; //此时设备已接收到你写入的数据 console.log(&quot;写入成功---&quot; + bluetoothInfo.writeUUid) macValue = &#x27;&#x27; &#125;, fail: (err) =&gt; &#123; console.log(err) &#125; &#125;) &#125;, //arraybuffer 转字符串 参数为ArrayBuffer对象 ab2str(str) &#123; // ArrayBuffer转16进度字符串示例 function ab2hex(buffer) &#123; const hexArr = Array.prototype.map.call( new Uint8Array(buffer), function(bit) &#123; return (&#x27;00&#x27; + bit.toString(16)).slice(-2) &#125; ) return hexArr.join(&#x27;&#x27;) &#125; //16进制 let systemStr = ab2hex(str) function hexCharCodeToStr(hexCharCodeStr) &#123; var trimedStr = hexCharCodeStr.trim(); var rawStr = trimedStr.substr(0, 2).toLowerCase() === &quot;0x&quot; ? trimedStr.substr(2) : trimedStr; var len = rawStr.length; if (len % 2 !== 0) &#123; alert(&quot;Illegal Format ASCII Code!&quot;); return &quot;&quot;; &#125; var curCharCode; var resultStr = []; for (var i = 0; i &lt; len; i = i + 2) &#123; curCharCode = parseInt(rawStr.substr(i, 2), 16); // ASCII Code Value let str5 = String.fromCharCode(curCharCode) if (str5.startsWith(&#x27;\\n&#x27;) == false) &#123; resultStr.push(String.fromCharCode(curCharCode)); &#125; &#125; return resultStr.join(&quot;&quot;); &#125; return hexCharCodeToStr(systemStr) &#125;, // 字符串转为ArrayBuffer对象，参数为字符串 str2ab(str) &#123; // 创建一个固定长度的二进制缓冲区 二进制ArrayBuffer对象 let buffer = new ArrayBuffer(str.length*2); // 在Unicode编码方案中，一个英文字符或一个汉字字符都占用两个字节的空间 // 操作二进制ArrayBuffer对象 let dataView = new DataView(buffer) for (var i=0, strLen = str.length; i&lt;strLen; i++) &#123; // 设置占8-bit的字节数组 一个字节 16进制数据 dataView.setUint8(i, parseInt((str.charCodeAt(i)).toString(16),16) ) // dataView.setUint8(i, &#x27;0X&#x27; + value.substring(i * 2, i * 2 + 2)); 错误写法 ：需要16进制数字类型 不能字符串 &#125; return buffer; &#125;,&#125; store代码 123456789101112131415161718192021222324252627282930import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; bluetooth:&#123;&#125;,//连接的蓝牙设备信息 &#125;, mutations: &#123; // 设置蓝牙连接数据 SET_BLUETOOTH(state,info)&#123; state.bluetooth = Object.assign(state.bluetooth,info) &#125; &#125;, actions: &#123; // 设置蓝牙信息 setBluetoothInfo(&#123;commit,state&#125;,&#123;data,callback&#125;)&#123; commit(&#x27;SET_BLUETOOTH&#x27;,data) if(callback)&#123;callback()&#125; &#125; &#125;, getters: &#123; // 获取蓝牙设备信息 getBluetoothInfo: state =&gt; state.bluetooth &#125;&#125;)export default store 十二、问题整个流程重点是，写入和监听数据。写入数据一定注意格式 搜索不到蓝牙设备 尝试添加权限： &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt; 连接蓝牙设备之后无法获取到serverUUid和蓝牙特征[uuid] 加个定时器延迟获取serverID 就可以获取 蓝牙设备返回的二进制数据无法打印出来 将返回的arraybuffer 转字符串 方法参考：https://juejin.cn/post/6846687590783909902#heading-19 uniapp权限模块参考地址：https://blog.csdn.net/zhanghuanhuan1/article/details/107520740","path":"2022/04/13/uniapp的蓝牙模块/","date":"04-13","excerpt":"","tags":[{"name":"app","slug":"app","permalink":"https://diamond-sjh.github.io/tags/app/"}]},{"title":"unipush的消息推送","text":"unipush的消息推送一、创建项目并开通unipush 申请开发者账号 方法一：在https://dev.dcloud.net.cn/app/index?type=0 网址申请DCloud开发者账号 方法二：在Hbuderx左下角点击未登录，然后注册账号 登录注册的开发者账号，创建h5或者是uniapp项目，进行开发。 配置manifest.json文件添加推送服务，先进行基础配置（AppId、应用名称等）。点击App模块配置，勾选Push(消息推送)–&gt;uniPush。点击配置跳转如下界面 编辑应用信息，如果想单独打包android可以不选中ios，然后点击开通推送服务就开启了。 注意：这里的android包名要与后面的厂商应用保持一致，应用签名要与华为平台上的签名文件使用同一个(SHA256) 至此，个推渠道已经配置完毕，app打包之后在线情况可以收到推送消息 二、注册手机厂商账号（华为为例） 直接到https://developer.huawei.com/consumer/cn/华为开发者联盟去注册账号，跟着提示一步步走 账号注册完后登录。到管理中心–&gt;上架及推送服务–&gt;我的项目–&gt;新建项目–&gt;添加应用 新建完成后，进入如下页面 项目创建完成后需要生成指纹证书文件（Android平台签名证书(.keystore)） 如果配置了java环境变量就可以直接往下走，如果没有就需要执行cd命令进入keytool.exe所在的目录（java安装目录的bin下）。 ​ （1）在命令行输入命令 1keytool -genkey -alias testalias -keyalg RSA -keysize 2048 -validity 36500 -keystore test.keystore testalias是证书别名，可修改为自己想设置的字符，建议使用英文字母和数字 test.keystore是证书文件名称，可修改为自己想设置的文件名称，也可以指定完整文件路径 (2) 然后跟据命令行提示操作生成keystore文件 ​ testalias是证书别名 ，还有证书文件密码和位置都需要记住打包的时候必须要。 ​ （3）查看keystore文件。输入以下命令 12keytool -list -v -keystore test.keystore Enter keystore password: //输入密码，回车 ​ 输出以下格式信息 123456789101112131415161718192021Keystore type: PKCS12 Keystore provider: SUN Your keystore contains 1 entry Alias name: test Creation date: 2019-10-28 Entry type: PrivateKeyEntry Certificate chain length: 1 Certificate[1]: Owner: CN=Tester, OU=Test, O=Test, L=HD, ST=BJ, C=CN Issuer: CN=Tester, OU=Test, O=Test, L=HD, ST=BJ, C=CN Serial number: 7dd12840 Valid from: Fri Jul 26 20:52:56 CST 2019 until: Sun Jul 02 20:52:56 CST 2119 Certificate fingerprints: MD5: F9:F6:C8:1F:DB:AB:50:14:7D:6F:2C:4F:CE:E6:0A:A5 SHA1: BB:AC:E2:2F:97:3B:18:02:E7:D6:69:A3:7A:28:EF:D2:3F:A3:68:E7 SHA256: 24:11:7D:E7:36:12:BC:FE:AF:2A:6A:24:BD:04:4F:2E:33:E5:2D:41:96:5F:50:4D:74:17:7F:4F:E2:55:EB:26 Signature algorithm name: SHA256withRSA Subject Public Key Algorithm: 2048-bit RSA key Version: 3 其中证书指纹信息（Certificate fingerprints）： MD5证书的MD5指纹信息（安全码MD5） SHA1证书的SHA1指纹信息（安全码SHA1） SHA256证书的SHA256指纹信息（安全码SHA245） 将生成的SHA256填入如图标记部分。 项目信息完成后，开通推送服务 将配置文件 agconnect-services.json文件下载保存，unipush配置厂商通道需要使用 三、配置unipush的厂商推送设置 厂商账号以及推送服务开通之后，回到unipush后台配置界面https://dev.dcloud.net.cn/app/index?type=0 点击自己需要配置的应用进入到unipush页面，点击厂商推送设置，将各个厂商的应用信息填入对应项中，保存。 将项目进行云打包，使用自有证书，上面生成的证书。填入证书别名，填入证书密码，填入证书路径，选择打正式包，然后点击打包，等待打包完成手机安装即可。 四、服务端代码准备：pom.xml文件12345678910111213&lt;dependency&gt; &lt;groupId&gt;com.gexin.platform&lt;/groupId&gt; &lt;artifactId&gt;gexin-rp-sdk-http&lt;/artifactId&gt; &lt;version&gt;4.1.1.4&lt;/version&gt;&lt;/dependency&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;getui-nexus&lt;/id&gt; &lt;url&gt;http://mvn.gt.getui.com/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; 后端Java：服务端集成时首先需要获取AppId、AppKey、MasterSecret参数，登录DCloud开发者中心，在“Uni Push”下的“应用配置”页面中获取，如下图所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import com.gexin.rp.sdk.base.IPushResult;import com.gexin.rp.sdk.base.impl.AppMessage;import com.gexin.rp.sdk.base.impl.SingleMessage;import com.gexin.rp.sdk.base.impl.Target;import com.gexin.rp.sdk.base.notify.Notify;import com.gexin.rp.sdk.base.payload.APNPayload;import com.gexin.rp.sdk.base.uitls.AppConditions;import com.gexin.rp.sdk.exceptions.RequestException;import com.gexin.rp.sdk.http.Constants;import com.gexin.rp.sdk.http.IGtPush;import com.gexin.rp.sdk.template.AbstractTemplate;import com.gexin.rp.sdk.template.LinkTemplate;import com.gexin.rp.sdk.template.NotificationTemplate;import com.gexin.rp.sdk.template.TransmissionTemplate;import com.gexin.rp.sdk.template.style.AbstractNotifyStyle;import com.gexin.rp.sdk.template.style.Style0;import org.springframework.stereotype.Service;public class UninAppNews &#123; //参照上方链接获取 private static String appId = &quot;&quot;; private static String appKey = &quot;&quot;; private static String masterSecret = &quot;&quot;; // 如果需要使用HTTPS，直接修改url即可 //private static String host = &quot;https://api.getui.com/apiex.htm&quot;; private static String host = &quot;http://api.getui.com/apiex.htm&quot;; private static String CID = &quot;&quot;;//前端获取 //指定用户推送 public void sendNews() &#123; // 设置后，根据别名推送，会返回每个cid的推送结果 System.setProperty(Constants.GEXIN_PUSH_SINGLE_ALIAS_DETAIL, &quot;true&quot;); IGtPush push = new IGtPush(host, appKey, masterSecret); NotificationTemplate template = getNotificationTemplate(); SingleMessage message = new SingleMessage(); message.setOffline(true); // 离线有效时间，单位为毫秒 message.setOfflineExpireTime(24 * 3600 * 1000); message.setData(template); // 可选，1为wifi，0为不限制网络环境。根据手机处于的网络情况，决定是否下发 message.setPushNetWorkType(0); // 厂商通道下发策略 message.setStrategyJson(&quot;&#123;\\&quot;default\\&quot;:4,\\&quot;ios\\&quot;:4,\\&quot;st\\&quot;:4&#125;&quot;); Target target = new Target(); target.setAppId(appId); target.setClientId(CID); //target.setAlias(Alias); IPushResult ret = null; try &#123; ret = push.pushMessageToSingle(message, target); &#125; catch (RequestException e) &#123; e.printStackTrace(); ret = push.pushMessageToSingle(message, target, e.getRequestId()); &#125; if (ret != null) &#123; System.out.println(ret.getResponse().toString()); &#125; else &#123; System.out.println(&quot;服务器响应异常&quot;); &#125; &#125; // 打开应用的首页 public static NotificationTemplate getNotificationTemplate() &#123; NotificationTemplate template = new NotificationTemplate(); // 设置APPID与APPKEY template.setAppId(appId); template.setAppkey(appKey); //设置展示样式 Style0 style = new Style0(); // 设置通知栏标题与内容 style.setTitle(&quot;请输入通知栏标题&quot;); style.setText(&quot;请输入通知栏内容&quot;); // 配置通知栏图标 style.setLogo(&quot;icon.png&quot;); //配置通知栏图标，需要在客户端开发时嵌入，默认为push.png // 配置通知栏网络图标 style.setLogoUrl(&quot;&quot;); // 配置自定义铃声(文件名，不需要后缀名)，需要在客户端开发时嵌入后缀名为.ogg的铃声文件 style.setRingName(&quot;sound&quot;); // 角标, 必须大于0, 个推通道下发有效; 此属性目前仅针对华为 EMUI 4.1 及以上设备有效 style.setBadgeAddNum(1); // 设置通知是否响铃，震动，或者可清除 style.setRing(true); style.setVibrate(true); style.setClearable(true); style.setChannel(&quot;通知渠道id&quot;); style.setChannelName(&quot;通知渠道名称&quot;); style.setChannelLevel(4); //设置通知渠道重要性 template.setStyle(style); template.setTransmissionType(2); // 透传消息设置，收到消息是否立即启动应用： 1为立即启动，2则广播等待客户端自启动 template.setTransmissionContent(&quot;请输入您要透传的内容&quot;); // template.setSmsInfo(PushSmsInfo.getSmsInfo()); //短信补量推送 // template.setDuration(&quot;2019-07-09 11:40:00&quot;, &quot;2019-07-09 12:24:00&quot;); // 设置定时展示时间，安卓机型可用 template.setNotifyid(123); // 在消息推送的时候设置notifyid。如果需要覆盖此条消息，则下次使用相同的notifyid发一条新的消息。客户端sdk会根据notifyid进行覆盖。 template.setAPNInfo(getAPNPayload()); //ios消息推送 return template; &#125; //ios样式模板 private static APNPayload getAPNPayload() &#123; APNPayload payload = new APNPayload(); //在已有数字基础上加1显示，设置为-1时，在已有数字上减1显示，设置为数字时，显示指定数字 payload.setAutoBadge(&quot;+1&quot;); payload.setContentAvailable(0); //ios 12.0 以上可以使用 Dictionary 类型的 sound payload.setSound(&quot;default&quot;); payload.setCategory(&quot;$由客户端定义&quot;); payload.addCustomMsg(&quot;由客户自定义消息key&quot;, &quot;由客户自定义消息value&quot;); //简单模式APNPayload.SimpleMsg // payload.setAlertMsg(new APNPayload.SimpleAlertMsg(&quot;给你发消息了&quot;)); payload.setAlertMsg(getDictionaryAlertMsg()); //字典模式使用APNPayload.DictionaryAlertMsg return payload; &#125; //ios消息体 private static APNPayload.DictionaryAlertMsg getDictionaryAlertMsg() &#123; APNPayload.DictionaryAlertMsg alertMsg = new APNPayload.DictionaryAlertMsg(); alertMsg.setBody(&quot;小何给你发消息了&quot;);//ios消息内容 alertMsg.setActionLocKey(&quot;显示关闭和查看两个按钮的消息&quot;); alertMsg.setLocKey(&quot;loc-key1&quot;); alertMsg.addLocArg(&quot;loc-ary1&quot;);// alertMsg.setLaunchImage(&quot;调用已经在应用程序中绑定的图形文件名&quot;); // iOS8.2以上版本支持 alertMsg.setTitle(&quot;通知标题&quot;);//ios消息标题// alertMsg.setTitleLocKey(&quot;自定义通知标题&quot;);// alertMsg.addTitleLocArg(&quot;自定义通知标题组&quot;); return alertMsg; &#125;&#125; 五、前端处理 代码需要放在app.vue中的onLaunch里面 1234567891011121314151617181920212223242526onLaunch: function() &#123; console.log(&#39;App Launch&#39;) &#x2F;&#x2F;#ifdef APP-PLUS let timer &#x3D; false; plus.push.addEventListener(&quot;click&quot;,(msg)&#x3D;&gt;&#123; clearTimeout(timer); timer &#x3D; setTimeout(()&#x3D;&gt;&#123; console.log(1111,msg); if(msg.payload)&#123; uni.navigateTo(&#123; url:msg.payload &#125;) &#125; &#125;,1500) &#125;,false) plus.push.addEventListener(&quot;receive&quot;,(msg)&#x3D;&gt;&#123; if(&quot;LocalMSG&quot; &#x3D;&#x3D; msg.payload)&#123; &#125;else&#123; if(msg.type&#x3D;&#x3D;&#39;receive&#39;)&#123; var options &#x3D; &#123;cover:false,title:msg.title&#125;; plus.push.createMessage(msg.content, msg.payload, options ); &#125; &#125; &#125;,false) &#x2F;&#x2F;#endif&#125; 注：华为配置产商渠道可能有延迟，配置完成可能等等再测试 消息推送模板：https://docs.getui.com/getui/server/java/template/?id=doc-title-8 消息推送demo的git：https://github.com/GetuiLaboratory/getui-pushapi-java-demo/tree/master/src/main/java/com/getui/platform/demo unipush参考：https://blog.csdn.net/weixin_42678675/article/details/115470016 ​ https://blog.csdn.net/object_oriented/article/details/106695077 ​ https://blog.csdn.net/z668899/article/details/109805595","path":"2021/04/21/unipush消息推送/","date":"04-21","excerpt":"","tags":[{"name":"app","slug":"app","permalink":"https://diamond-sjh.github.io/tags/app/"}]},{"title":"Vue Router","text":"路由router什么是路由组件切换是通过变换url地址的锚点信息而显示不同的组件，路由也是如此，也是 浏览器地址信息 与 组件 的映射关系体现，但路由是组件切换SPA的封装版本，使用起来要更加方便、高效 官网参考 上图 浏览器锚点发生变化，会被onhashchange感知 然后window.location.hash获得变换后的锚点信息 通过锚点获得用于显示组件的标签名称 标签名称赋予给component标签的is属性 组件就呈现 以上锚点找到对应组件的过程就是路由 路由对 component标签、onhashchange、window.location.hash、等原始内容做了封装，是更高级组件切换的体现 在 vue 中使用 vue-router安装路由vue-router路由是一个js功能模块，在使用的时候需要先安装 运行指令 1yarn add vue-router 应用路由 在入口文件处导入路由模块(index.js) 1import VueRouter from &#x27;vue-router&#x27; 注册路由模块(index.js) 把导入的路由模块注册给Vue Vue.use(xxx)就是要把某个功能模块注册给Vue， 该操作类似通过Vue.component()方式给Vue注册组件， 注册多个组件需要多次执行Vue.component()，而Vue.use()可以一次性注册全部的组件，使用更给力，其本身也有其他功能，后续会介绍。 1Vue.use(VueRouter) 导入要显示组件(index.js) 把要显示的子级组件导入进来 123import Home from &#x27;./home.vue&#x27;;import About from &#x27;./about.vue&#x27;;import Movie from &#x27;./movie.vue&#x27;; 事先把对应的 home.vue、about.vue、movie.vue子组件和内容创建好 创建路由对象(index.js)创建路由对象，并把hash和组件的对应关系设置好 12345678const router = new VueRouter(&#123; // 配置对象中，要提供 hash 地址 到 组件之间的 对应关系 routes: [ // 这个 routes 就是 路由 规则 的数组，里面要放很多的对应关系 // &#123; path: &#x27;hash地址&#x27;, component: 组件对象 &#125; &#123; path: &#x27;/home&#x27;, component: Home &#125;, &#123; path: &#x27;/user&#x27;, component: Movie &#125;, &#123; path: &#x27;/about&#x27;, component: About &#125; ]&#125;) 挂载路由(index.js)把创建好的 router 对象，挂载到 主vm 对象上 12345const vm = new Vue(&#123; el: &#x27;#app&#x27;, render: c =&gt; c(App), router // 把 创建的路由对象挂载到 VM 实例上，与 router:router 效果一致&#125;) 创建路由链接(App.vue) 在主vue组件中，通过router-link方式应用超链接 router-link标签：用以创建 路由的 hash锚点 超链接 to 属性，表示 点击此链接，要跳转到哪个 hash锚点 请求地址 123&lt;router-link to=&quot;/home&quot;&gt; 首页 &lt;/router-link&gt;&lt;router-link to=&quot;/user&quot;&gt; 会员 &lt;/router-link&gt;&lt;router-link to=&quot;/movie&quot;&gt; 电影 &lt;/router-link&gt; to 属性中，不需要以 # 开头 router-link编译后会变成具体的html标签效果： 设置容器(App.vue) 在App.vue根组件中通过router-view标签设置显示组件的容器 1&lt;router-view&gt; &lt;/router-view&gt; router-view的作用类似于component标签，设定占位符，用以显示各个业务子组件 路由规则的匹配过程： 用户点击 页面的 路由链接router-link，点击的一瞬间，就会修改 浏览器 地址栏 中的 Hash 锚点地址信息， 当 hash 信息被修改以后，会立即被 路由 监听到 (路由有封装onhashchange事件) 在onhashchange事件里边感知变化后的hash锚点信息(window.location.hash)，然后与对应的组件进行联系 组件被显示，具体是通过路由占位符rouer-view进行显示 redirect重定向用户第一次访问网站页面(“/根目录”首页)时，地址栏里边没有“hash锚点”的信息，也就没有对应的组件用于显示，明显项目体验不好，现在可以通过redirect实现重定向效果即 设定“/根目录”与一个具体路由联系起来，这样即使浏览器地址栏没有任何锚点信息，也有默认的组件进行显示 使用示例： 1234567const router = new VueRouter(&#123; routes:[ &#123;path:&#x27;/&#x27;, redirect: &#x27;/mv&#x27;&#125;, &#123;path:&#x27;/mv&#x27;, component: Movie&#125;, ]&#125;) 当访问”/根目录”时，就重定向到”/mv锚点”，进而显示Movie组件 路由按钮高亮官网参考 在App.vue主页面中(router-link超链标签使用页面)通过router-link-active选择器设置如下样式： 1234&lt;style lang=&quot;less&quot; scoped&gt;.router-link-active &#123;background-color: lightgreen;&#125;&lt;/style&gt; 当前超链按钮被单击选中会有浅绿背景颜色高亮显示 被点击激活的按钮，本身有class属性值，直接进行css样式设定即可： 嵌套路由（子路由）路由的应用是在App.vue根组件中通过单击超链按钮切换显示不同子组件，具体表现就是父、子组件嵌套关系 有的应用比较复杂，子组件内部还有子组件，形成了 1级App.vue组件–&gt;2级业务组件–&gt;3级业务组件 的效果，现在学习如何在 2级组件 中切换显示 3级组件 使用步骤： 在2级组件中设置 切换标签 和 显示的组件容器 12345&lt;router-link to=&#x27;/music/hongkong&#x27;&gt;香港&lt;/router-link&gt;&lt;router-link to=&#x27;/music/taiwan&#x27;&gt;台湾&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt; router-link：设置超链按钮 router-view：第3级组件显示的容器 在对应的路由规则中，通过 children 属性，定义子路由规则： 1234567891011121314151617var router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/&#x27;, redirect: &#x27;/user&#x27; &#125;, &#123; path: &#x27;/home&#x27;, component: Home &#125;, &#123; path: &#x27;/user&#x27;, component: User &#125;, &#123; path: &#x27;/movie&#x27;, component: Movie, children: [ &#123; path: &#x27;/movie/hongkong&#x27;, component: Hongkong &#125;, &#123; path: &#x27;/movie/taiwan&#x27;, component: Taiwan &#125;, &#123; path: &#x27;/movie/dalu&#x27;, component: Dalu &#125; ] &#125; ]&#125;) 重定向 如果需要redirect重定向效果可以像如下两种方式设置，任选一个即可： 12345678910111213141516171819var router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/&#x27;, redirect: &#x27;/user&#x27; &#125;, &#123; path: &#x27;/home&#x27;, component: Home &#125;, &#123; path: &#x27;/user&#x27;, component: User &#125;, &#123; path: &#x27;/movie&#x27;, component: Movie, redirect: &#x27;/movie/hongkong&#x27;, // 1) 方式重定向 children: [ &#123; path: &#x27;&#x27;, redirect:&#x27;/movie/hongkong&#x27; &#125;, // 2) 方式重定向 &#123; path: &#x27;/movie/hongkong&#x27;, component: Hongkong &#125;, &#123; path: &#x27;/movie/taiwan&#x27;, component: Taiwan &#125;, &#123; path: &#x27;/movie/dalu&#x27;, component: Dalu &#125; ] &#125; ]&#125;) 重定向注意： 方式1 设置redirect成员的同时也需要component成员 路由传参使用步骤： 在路由中设定参数 123456789101112const router = new VueRouter(&#123; routes:[ &#123; path: &#x27;/music, component: Music, children: [ &#123;path:&#x27;/dt/:mid&#x27;, component: Detail, props:true&#125; ] &#125; ]&#125;) :mid 表示当前路由有一个参数，名称为mid, :冒号 是必须的(需要时可以通过相同的方式声明多个参数)props:true 表示当前路由有参数需要传递 在router-link超链地方把需要的参数设置好 12&lt;router-link :to=&quot;/dt/1001&quot;&gt;XXX&lt;/router-link&gt; 通过to属性对“参数”一并进行设置 router-link默认生成a标签，如果想生成其他标签，可以通过如下方式实现 12&lt;router-link tag=&quot;li&quot; :to=&quot;/dt/1001&quot;&gt;XXX&lt;/router-link&gt; tag=”li” 表示生成li标签，并且超链效果仍然有效，可以参考 参数的接收和使用 12345678&lt;p&gt;电影详情展示---&#123;&#123; mid &#125;&#125;&lt;/p&gt;&lt;script&gt;export default &#123; // 通过props接收的路由参数信息，名称为mid props:[&#x27;mid&#x27;]&#125;&lt;/script&gt; 要通过props对路由参数进行接收 props对两种数据都可以接收： 路由参数 父组件给传递过来的数据 编程式导航导航：一个路由切换到另外一个路由去(/mv /dt/102) 什么是router-link是通过静态超链接按钮的方式把各个用于显示的组件给声明好，单击哪个按钮就显示哪个组件，其被称为声明式导航 有时并不能通过单击超链按钮来显示一个组件，例如判断用户是登录状态就显示业务组件页面，否则显示登录组件页面，这时需要通过程序代码实现组件的判断显示，通过编写程序代码的方式实现组件显示就称为编程式导航 使用语法12345this.$router.push(路由地址) // 根据路由信息显示组件,可以是router-link标签的to属性值this.$router.go(n) // n可以是 负数、0、正数，表示页面要 回退、刷新、前进 this.$router.forward() // 前进this.$router.back() // 后退 灵感来自bom浏览器对象模型 window.history.go() window.history.back() window.history.forward() 官网参考 路由守卫路由对象有一个名称为beforeEach的方法，每个路由在加载组件之前都要调用它，在这个方法中可以做逻辑判断，限制要做什么或不做什么，这个过程称为路由守卫，有着一夫当关万夫莫开的效果 语法12router.beforeEach((to, from, next) =&gt; &#123; /* 导航守卫 处理逻辑 */ &#125;) 这里的 router 就是 new VueRouter 得到的 路由对象 beforeEach()是路由在显示组件之前要执行的代码 参数1 to:是一个对象，保存着将要访问路由相关的参数 from:是一个对象，保存着离开的那个页面的相关路由参数 next:是一个函数，对后续的执行起着 拦截 或 放行 的作用 如果没有问题请一定执行next()方法，以进行后续操作， next()方法也可以通过传递路由信息实现其他组件的显示 例如：next(‘/login’) 显示登录组件","path":"2018/12/15/Vue-Router/","date":"12-15","excerpt":"","tags":[{"name":"vue","slug":"vue","permalink":"https://diamond-sjh.github.io/tags/vue/"}]},{"title":"vue生命周期","text":"vue生命周期什么是生命周期定义：生命周期是指vue实例(或者组件)从诞生到消亡所经历的各个阶段的总和 生命周期： vue在使用的过程中，分为多个阶段，具体有创建、运行、销毁，并且可以通过成员方法感知到 创建阶段由空白期、data初始化、methods初始化、模板渲染等组成 运行阶段分为 更新前 和 更新后 两部分 销毁阶段分为 销毁前 和 销毁后 不同阶段完成不同的任务，开发者可以利用各个阶段的特点完成业务需要的相关功能 beforeCreate：可以在这加个loading事件，在加载实例的时候触发 created：初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted：挂载元素，获取到DOM节点 updated：如果对数据同意处理，在这里写上相应函数 beforeDestroy：可以做一个确认停止事件的确认框 生命周期参考 生命周期函数分类创建阶段 创建期间的生命周期函数：(特点：每个实例一辈子只执行一次，并且是自动的) beforeCreate：创建之前，此时 data 和 methods 尚未初始化 created : 第一个重要的函数，此时，data 和 methods 已经创建好了，可以被访问，在此处非常适合做data数据初始化操作 beforeMount：挂载容器模板结构之前，此时，容器的内容已经被Vue获取到了(容器本身还是未解析的原始内容)； 现在Vue实例就被称为 Virtual DOM(虚拟DOM) mounted 第二个重要的函数，此时，容器被vue渲染解析完毕；是操作初始DOM元素的最好时机 1234567beforeCreate() &#123; console.group(&#x27;---------beforeCreate调用--------&#x27;) console.log(&#x27;%c%s&#x27;, &#x27;color:red&#x27;, &#x27;el现在的样子：&#x27; + this.$el) // undefined console.log(&#x27;%c%s&#x27;, &#x27;color:red&#x27;, &#x27;data现在的样子：&#x27; + this.$data) // undefined console.log(&#x27;%c%s&#x27;, &#x27;color:red&#x27;, &#x27;methods方法现在的样子：&#x27; + this.getInfo) // undefined &#125; console.group() 按照组别对调试信息进行划分 %c: 给调试信息设置样式，通过log的第2个参数体现 $s: 通过string字符串方式输出信息，通过log的第3个参数体现 this.$el: 获得到与Vue实例关联的容器 this.$data: 获得data全部的成员，以对象形式返回 this.getInfo: 把methods成员方法当做普通变量获取输出 1234567created() &#123; console.group(&#x27;---------created调用--------&#x27;) console.log(&#x27;%c%s&#x27;, &#x27;color:red&#x27;, &#x27;el现在的样子：&#x27; + this.$el) // undefined console.log(&#x27;%c%s&#x27;, &#x27;color:red&#x27;, &#x27;data现在的样子：&#x27; + this.$data) // 实体 console.log(&#x27;%c%s&#x27;, &#x27;color:red&#x27;, &#x27;methods方法：&#x27; + this.getDate) // 实体 &#125; 在此函数中适合进行Vue数据初始化(获取首屏数据)操作 123456beforeMount() &#123; console.group(&#x27;---------beforeMount调用--------&#x27;) console.log(&#x27;%c%s&#x27;, &#x27;color:red&#x27;, &#x27;el现在的样子：&#x27; + this.$el) // 实体 console.log(this.$el) // 编译【前】的实体内容 &#125; 123456mounted() &#123; console.group(&#x27;---------mounted调用--------&#x27;) console.log(&#x27;%c%s&#x27;, &#x27;color:red&#x27;, &#x27;el现在的样子：&#x27; + this.$el) // 实体 console.log(this.$el) // 编译【后】的实体内容 &#125; 此时适合对页面dom元素做初始化操作 运行阶段 运行期间的生命周期函数：（特点：按需被调用 至少0次，最多不限制） beforeUpdate：根据最新的数据重新解析渲染浏览器页面，此时 vue虚拟数据是最新的，但是页面还是旧的 updated：页面和数据都是最新的页面已经完成了更新，此时data数据和页面都是最新的 123456789beforeUpdate() &#123; console.group(&#39;---------beforeUpdate调用--------&#39;) console.log( &#39;%c%s&#39;, &#39;color:red&#39;, &#39;h2数据更新之前的效果：&#39; + document.querySelector(&#39;h2&#39;).innerHTML )&#125; 123456789updated() &#123; console.group(&#39;---------updated调用--------&#39;) console.log( &#39;%c%s&#39;, &#39;color:red&#39;, &#39;h2数据更新之后的效果：&#39; + document.querySelector(&#39;h2&#39;).innerHTML )&#125; 有 “Virtual DOM(虚拟DOM)”，其是Vue实例获取到的div容器，是虚拟的(不是页面实实在在看到的)，该VirtualDOM 在Vue的生命周期运行阶段始终存在，随时感知数据变化，随时同步给页面 销毁阶段 销毁期间的生命周期函数：(特点：每个实例一辈子只执行一次) beforeDestroy：将要销毁，处于销毁之前阶段，实例还正常可用 destroyed：销毁之后，Vue实例已经不工作了 123456beforeDestroy() &#123; console.group(&#39;---------beforeDestroy调用--------&#39;) console.log(&#39;%c%s&#39;, &#39;color:red&#39;, &#39;el现在的样子：&#39; + this.$el)&#125;, 12345destroyed() &#123; console.group(&#39;---------destroyed调用--------&#39;) console.log(&#39;%c%s&#39;, &#39;color:red&#39;, &#39;el现在的样子：&#39; + this.$el)&#125; 完整应用示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--创建一个div容器，vue对该容器进行控制，设置要显示的内容--&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script src=&quot;./vue-2.6.10.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; // 1) 生命周期创建阶段(4个函数),会自动执行 beforeCreate()&#123; // Vue实例已经创建完毕，但是相关的成员都没有，el、methods、data等等都没有 console.group(&#x27;--------beforeCreate发生调用--------&#x27;) console.log(&#x27;%c%s&#x27;,&#x27;color:red&#x27;,&#x27;el现在的样子：&#x27;+this.$el) // undefined console.log(&#x27;%c%s&#x27;,&#x27;color:red&#x27;,&#x27;data现在的样子：&#x27;+this.$data) // undefined console.log(&#x27;%c%s&#x27;,&#x27;color:red&#x27;,&#x27;getDate现在的样子：&#x27;+this.getDate) // undefined &#125;, created()&#123; // 该阶段是一个【重要】阶段，此时data 和 methods已经准备好了，但是还没有去找div容器 // 此阶段可以用于页面首屏数据获取操作，获取回来的数据存储给data的某个成员即可 console.group(&#x27;--------created发生调用--------&#x27;) console.log(&#x27;%c%s&#x27;,&#x27;color:red&#x27;,&#x27;el现在的样子：&#x27;+this.$el) // undefined console.log(&#x27;%c%s&#x27;,&#x27;color:red&#x27;,&#x27;data现在的样子：&#x27;+this.$data) // 实体 console.log(&#x27;%c%s&#x27;,&#x27;color:red&#x27;,&#x27;getDate现在的样子：&#x27;+this.getDate) // 实体 &#125;, beforeMount()&#123; // 此阶段完成了Vue实例对象 与 div容器联系的过程(本质是div容器已经被Vue实例获取到了) // 但是div容器的内容还是没有编译前的原生内容 console.group(&#x27;--------beforeMount发生调用--------&#x27;) console.log(&#x27;%c%s&#x27;,&#x27;color:red&#x27;,&#x27;el现在的样子：&#x27;+this.$el) // 实体 console.log(document.getElementsByTagName(&#x27;h2&#x27;)[0]) // &#125;, mounted()&#123; // 此阶段 Vue实例已经完成了div容器的内容的编译，并且编译好的内容也渲染给div容器了 console.group(&#x27;--------mounted发生调用--------&#x27;) console.log(&#x27;%c%s&#x27;,&#x27;color:red&#x27;,&#x27;el现在的样子：&#x27;+this.$el) // 实体 console.log(document.getElementsByTagName(&#x27;h2&#x27;)[0]) // 容器编译【后】实体内容 &#125;, // 2) 生命周期运行阶段(2个函数),data数据变化后才会执行 beforeUpdate() &#123; console.group(&#x27;---------beforeUpdate调用--------&#x27;) console.log( &#x27;%c%s&#x27;, &#x27;color:red&#x27;, &#x27;h2数据更新【前】的效果：&#x27; + document.querySelector(&#x27;h2&#x27;).innerHTML ) &#125;, updated() &#123; console.group(&#x27;---------updated调用--------&#x27;) console.log( &#x27;%c%s&#x27;, &#x27;color:red&#x27;, &#x27;h2数据更新【后】的效果：&#x27; + document.querySelector(&#x27;h2&#x27;).innerHTML ) &#125;, // 3) 生命周期销毁阶段(2个函数),只有vm调用$destroy()方法后才执行 beforeDestroy() &#123; console.group(&#x27;---------beforeDestroy调用--------&#x27;) console.log(&#x27;%c%s&#x27;, &#x27;color:red&#x27;, &#x27;el现在的样子：&#x27; + this.$el) &#125;, destroyed() &#123; console.group(&#x27;---------destroyed调用--------&#x27;) console.log(&#x27;%c%s&#x27;, &#x27;color:red&#x27;, &#x27;el现在的样子：&#x27; + this.$el) &#125;, el: &#x27;#app&#x27;, data: &#123; msg: &#x27;生命周期学习篇&#x27; &#125;, methods: &#123; getDate()&#123; console.log(&#x27;Sunday&#x27;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 小结：生命周期创建阶段的created和mounted两个函数最经常使用，其他了解即可 created：一般用于页面首屏data数据初始化使用 mounted：可对渲染完毕的页面做dom初始化操作(例如给dom元素设置事件)","path":"2018/11/28/vue生命周期/","date":"11-28","excerpt":"","tags":[{"name":"vue","slug":"vue","permalink":"https://diamond-sjh.github.io/tags/vue/"}]},{"title":"回调函数闭包递归","text":"1、函数作为函数参数(回调函数) 现象：把一个函数B当做实参，传递给另一个函数的A的形参，并在函数A内部调用 参数： 形参：函数定义时，小括号中的标识符 实参：函数调用时，小括号中实际的数据 关系：实参代表的实际数据传递给函数内部的形参使用。 应用场景：当外部向函数内部传入数据时。 代码： 123456789101112// 定义函数A// v是形参function A(v) &#123; v(11,22);&#125;// 调用A( // 函数B function (a,b) &#123; console.log(a + b); &#125;); 图解： 1.2 函数作为函数的返回值 关键字：return 数据; 应用：函数内部要把结果暴露给外部时使用返回值 代码： 123456789// 【返回值是函数时】 function fn() &#123; return function()&#123; console.log(&#x27;我是内部的的函数&#x27;); &#125;; &#125; // 调用函数 var r = fn(); r(); 图解： 3、闭包 变量的生命周期：什么时候在内存中被释放 全局变量的生命周期：程序关闭。 局部变量的生命周期：函数执行结束后。 作用域： 内层 可以 访问 外层，反之不行 闭包的作用： 目的延长局部变量的生命周期 维护私有变量-局部变量的安全 GC（Garbage Collection）垃圾回收机制 回收没有用的数据。 有用的数据：被全局中操作的变量。 闭包的概念： MDN：闭包是函数和声明该函数的词法环境的组合。 百度百科： ​ 闭包(Closure)就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的==桥梁==。 总结：桥梁 代码： 12345678910// 生活：藏在别墅中的三儿，被外部的朝阳群众操作了。 function bieShu () &#123; var a = &#x27;三儿&#x27;; // 局部变量 var guanJia = function() &#123; console.log(a); // 操作了外部的局部变量 &#125;; return guanJia; // 返回了子函数的地址 &#125; var cyqz = bieShu(); // 接收了子函数的地址 cyqz(); 图解： 如何检测一个程序是否存在闭包 外层函数 和 子函数 外层函数必须有局部变量 子函数要操作外层函数的局部变量 让子函数和外部产生关联（关联不一定是返回函数） 或者， 浏览器F12打开开发者工具 点到 Sources 一栏 打开html文档 在子函数内部设置断点，刷新 检查右边的 Scope 存在Closure即存在闭包 4、递归 递归的优点：减少代码量 递归的缺点：消耗内存，内存栈溢出,报错！ 4.1 什么是递归 函数调用自身的编程技巧。 官方概念 程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量** 。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有==边界条件== 、==递归前进段== 和==递归返回段== 。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。 4.2 递归的三个阶段 递归前进段 递归边界条件 递归返回段 案例： 例子1– –如：一组有规律的年龄10 、12、14、16、18、20、22、24……，求第n个人的年龄 123456789101112131415161718192021222324252627282930// 规律：第n个人的年龄 = 第n-1个人的年龄 + 2// 创建一个函数function age(n) &#123; if(n==1) &#123; return 10; &#125;else &#123; return age(n-1) + 2; &#125;&#125;// 调用var r = age(5); // 若fn的形参超过一定数值，会导致内存栈溢出报错。如：age(5000)，系统会报错console.log(r); // 运行过程如下// -------------------------递归前进段// age(5) // 等待...// age(4) + 2 // 等待...// age(3) + 2 // 等待...// age(2) + 2 // 等待...// age(1) + 2// age(1) 10 // -------递归边界条件// -------------------------递归返回段// age(2) 12// age(3) 14// age(4) 16// age(5) 18 例子2– –如：一组有规律的数字1、1、2、3、5、8、13….，求第n个数字 123456789101112// 规律：第n个数字的结果 = 第n-1个数字的结果 + 第n-2个数字的结果function fn(n) &#123; if(n==1||n==2) &#123; return 1; &#125;else &#123; return fn(n-1) + fn(n-2); &#125;&#125;var r = fn(30); // 若fn的形参超过一定数值，会导致内存栈溢出报错。如：fn(3000)，系统会报错console.log(r);","path":"2017/06/15/回调函数闭包递归/","date":"06-15","excerpt":"","tags":[{"name":"javascript","slug":"javascript","permalink":"https://diamond-sjh.github.io/tags/javascript/"}]},{"title":"浅拷贝和深拷贝","text":"1、浅拷贝和深拷贝 拷贝：对象之间的拷贝。 一个对象拷贝另一个对象中成员 1.1 浅拷贝 浅拷贝：针对赋值数据成员，拷贝时，仅仅拷贝地址，堆中的数据有被拷贝。 代码： 12345678910111213141516171819202122232425262728// 定义函数 参数fu，表示父对象 参数zi，表示子对象function copy(fu, zi) &#123; for (var key in fu) &#123; if (zi[key] == undefined) &#123; zi[key] = fu[key]; &#125; &#125;&#125;// 父对象var wjl = &#123; name: &#x27;王一&#x27;, money: 100000000, houses: [&#x27;别墅1&#x27;, &#x27;玩大2&#x27;, &#x27;毛坯3&#x27;, &#x27;瓦房4&#x27;], cars: [&#x27;宝马&#x27;, &#x27;奔驰&#x27;, &#x27;拖拉机&#x27;, &#x27;三蹦子&#x27;]&#125;;// 子对象1var wsc = &#123; name: &#x27;王二&#x27;&#125;// 子对象var wxc = &#123; name: &#x27;王三&#x27;&#125;copy(wjl, wsc);copy(wjl, wxc); 1.2 深拷贝 深拷贝：在堆中开辟新的空间拷贝堆中父对象的数据，在栈中开辟新的空间存堆空间中数据的地址 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 参数fu，表示父对象// 参数zi，表示子对象function copy(fu, zi) &#123; for (var key in fu) &#123; if (zi[key] == undefined) &#123; zi[key] = fu[key]; &#125; &#125;&#125;// 参数fu，表示父对象// 参数zi，表示子对象function deepCopy(fu, zi) &#123; for (var key in fu) &#123; if (zi[key] == undefined) &#123; // 判断是否是数组 if (fu[key] instanceof Array) &#123; // 子对象要开辟新的空间存放数组 zi[key] = new Array(); // 把父对象数组中成员 拷贝 到子对象的数组中 copy(fu[key],zi[key]) // 区别 &#125; else &#123; zi[key] = fu[key]; &#125; &#125; &#125;&#125;// 父对象var wjl = &#123; name: &#x27;王大&#x27;, money: 100000000, houses: [&#x27;别墅1&#x27;, &#x27;玩大2&#x27;, &#x27;毛坯3&#x27;, &#x27;瓦房4&#x27;], cars: [&#x27;宝马&#x27;, &#x27;奔驰&#x27;, &#x27;拖拉机&#x27;, &#x27;三蹦子&#x27;]&#125;;// 子对象1var wsc = &#123; name: &#x27;王二&#x27;&#125;// 子对象var wxc = &#123; name: &#x27;王三&#x27;&#125;deepCopy(wjl, wsc);deepCopy(wjl, wxc); 深拷贝–递归 1234567891011121314151617181920212223242526272829303132333435363738// 参数fu，表示父对象// 参数zi，表示子对象function deepCopy(fu, zi) &#123; for (var key in fu) &#123; if (zi[key] == undefined) &#123; // 判断是否是数组 if (fu[key] instanceof Array) &#123; // 子对象要开辟新的空间存放数组 zi[key] = new Array(); // 把父对象数组中成员 拷贝 到子对象的数组中 deepCopy(fu[key],zi[key]) // 区别 &#125; else &#123; zi[key] = fu[key]; &#125; &#125; &#125;&#125;// 父对象var wjl = &#123;name: &#x27;王大&#x27;,money: 100000000,houses: [&#x27;别墅1&#x27;, &#x27;玩大2&#x27;, &#x27;毛坯3&#x27;, &#x27;瓦房4&#x27;],cars: [&#x27;宝马&#x27;, &#x27;奔驰&#x27;, &#x27;拖拉机&#x27;, &#x27;三蹦子&#x27;]&#125;;// 子对象1var wsc = &#123;name: &#x27;王二&#x27;&#125;// 子对象var wxc = &#123;name: &#x27;王三&#x27;&#125;deepCopy(wjl, wsc);deepCopy(wjl, wxc);","path":"2017/05/28/浅拷贝和深拷贝/","date":"05-28","excerpt":"","tags":[{"name":"javascript","slug":"javascript","permalink":"https://diamond-sjh.github.io/tags/javascript/"}]},{"title":"函数内this指向以及改变this指向","text":"1、函数也是对象 函数的创建==&gt;底层都是new关键字创建函数 函数声明： 123function sum(a,b) &#123; console.log(a + b);&#125; 函数表达式： 123var sum = function sum(a,b) &#123; console.log(a + b);&#125; new关键字创建函数： 123// 语法：var 变量名 = new Function (&#x27;形参1&#x27;，&#x27;形参2&#x27;，...，&#x27;函数体中的代码&#x27;)var sum = new Function(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;console.log(a + b)&#x27;);sum(10,20); 2、函数内部this的指向 this的指向关键是看函数的调用方法 2.1 普通函数中this的指向 this指向window 代码： 1234567891011121314151617181920212223// 【在普通函数中this指向window】// function fn() &#123;// console.log(this);// &#125;// fn();// var fn = function() &#123;// console.log(this);// &#125;;// fn();// (function()&#123;// console.log(this);// &#125;)();function fn1() &#123; function fn2() &#123; console.log(this); &#125; fn2();&#125;fn1(); 2.2 构造函数中this的指向 this指向当前创建的对象—-在内存中开辟的空间 代码： 123456789101112 // 【在构造函数中this指向当前创建的对象】function Student(name,age) &#123; this.name = name; this.age =age;&#125;// 原型中添加方法Student.prototype.sayHi = function() &#123; console.log(&#x27;我叫&#x27; + this.name);&#125;;var stu1 = new Student(&#x27;张三&#x27;,10); // ==&gt;this指向stu1var stu2 = new Student(&#x27;李四&#x27;,10); // ==&gt;this指向stu2 2.3 对象方法中的this指向 this指向调用者 代码： 123456789101112// 【在方法中，this指向调用者。 对象.方法（）】function Student(name,age) &#123; this.name = name; this.age =age;&#125;// 原型中添加方法Student.prototype.sayHi = function() &#123; console.log(&#x27;我叫&#x27; + this.name);&#125;;var stu1 = new Student(&#x27;张三&#x27;,10); // ==&gt;this指向stu1stu1.sayHi(); // ==&gt;方法sayHi中的this指向stu1 2.4 定时器中this的指向 this指向window 代码： 1234// 【在定时器中this指向windnow】setTimeout(function()&#123; console.log(this);&#125;,5000); 2.5 事件处理程序中this指向 this指向事件源 代码： 1234// 【在事件处理程序中，this指向事件源】document.onclick = function() &#123; console.log(this);&#125;; 3、改变this的指向3.1 call方法 语法：函数名.call(调用者，实参1…) 作用：函数被借用时，会立即执行，并且函数体内的this会指向调用者(借用者) 代码： 123456789function fn(name, age) &#123; this.name = name; this.age = age; console.log(this == obj); //==&gt;true&#125; // 对象字面量var obj = &#123;&#125;;fn.call(obj, &#x27;李四&#x27;, 11); //==&gt;fn中的this指向obj 3.2 apply方法 语法：函数名.apply(调用者，[实参1，实参2,….]) ==&gt;参数以数组的形式 作用：函数被借用是，会立即执行，并且函数体内的this会指向调用者(借用者) 代码： 123456789function fn(name, age) &#123; this.name = name; this.age = age; console.log(this == obj); //==&gt;true&#125; // 对象字面量var obj = &#123;&#125;;fn.call(obj, [&#x27;李四&#x27;, 11]); //==&gt;fn中的this指向obj 3.3 bind方法 语法：函数名.bind(调用者，实参1….) 作用：函数被借用时，不会立即执行，而是返回一个新的函数。需要自己手动调用新的函数。 代码： 1234567891011function fn(name, age) &#123; this.name = name; this.age = age; console.log(this == obj); //==&gt;true &#125; // 对象字面量 var obj = &#123;&#125;; var newFn = fn.bind(obj, &#x27;李四&#x27;, 11); newFn();// fn.bind(obj, &#x27;李四&#x27;, 11)(); 3.4 使用 代码： 123456789101112// this指向windowvar name = &#x27;window&#x27;;var obj = &#123;name = &#x27;obj&#x27;&#125;;setTimeout(function()&#123; console.log(this.name); //==&gt;输出window&#125;,2000)// this指向objvar name = &#x27;window&#x27;;var obj = &#123;name = &#x27;obj&#x27;&#125;;setTimeout(function()&#123; console.log(this.name); //==&gt;输出obj&#125;.bind(obj),2000) // bind不会立即执行 伪数组借用数组的push方法实现增加 代码： 12345678910111213var arr = [10,20,30,40];// arr.push(50); // push为数组中的方法var obj = &#123; 0:10, 1:20, 2:30, 3:40, length:4&#125;// console.log(arr instanceof Array); ==&gt;true// console.log(obj instanceof Array); ==&gt;false// Array.prototype.push ==&gt;构造函数Array的原型中的push方法Array.prototype.push.call(obj,50); // ==&gt;改变push中this指向为obj","path":"2017/05/20/函数内this指向以及改变this指向/","date":"05-20","excerpt":"","tags":[{"name":"javascript","slug":"javascript","permalink":"https://diamond-sjh.github.io/tags/javascript/"}]},{"title":"JS中简单的几种继承方法","text":"1、继承介绍 ES6之前没有方法直接实现继承，这里的继承是利用技巧方法来模拟实现； 作用：减少代码或简化代码 生活：子承父业 编程：类与类之间的关系。子类继承父类中的成员 不使用继承，类与类之间可能有重复的属性和方法： 学生类：姓名、年龄、性别、学号、打招呼、跑 医生类：姓名、年龄、性别、钱、打招呼、跑 老师类：姓名、年龄、性别、工号、打招呼、跑 …… 使用继承，把不同类之间相同的属性和方法重新定义为一个类的： 人类[父类]：姓名、年龄、性别、打招呼、跑 学生类[子类]→人类[父类] 医生类[子类]→人类[父类] 老师类[子类]→人类[父类] …… 2、原型继承 优缺点： 优点：完美继承了方法 缺点：无法完美继承属性 如何实现原型继承： ①先更改子类的原型prototype指向父类的一个实例对象。 子类.prototype = new 父类(); ②再给子类的原型(即new 父类())设置一个constructor指向该子类 子类.prototype.constructor = 子类； 图解： 代码： 1234567891011121314151617181920212223242526272829// 人类 → 父类 function Person() &#123; this.name = &#x27;名字&#x27;; this.age = 10; this.gender = &#x27;男&#x27;; &#125; Person.prototype.sayHi = function () &#123; console.log(&#x27;你好&#x27;); &#125;; Person.prototype.eat = function () &#123; console.log(&#x27;我会吃。。。&#x27;); &#125;; Person.prototype.play = function () &#123; console.log(&#x27;我会玩&#x27;); &#125;; // 学生类 → 子类 function Student() &#123; this.stuId = 1000; &#125; // 子类的原型prototyp指向父类的一个实例对象 Student.prototype = new Person(); // 添加一个constructor成员 Student.prototype.constructor = Student; // 如何实现原型继承： // 给子类的原型prototype重新赋值为父类的一个实例对象。 // 利用了原型链上属性或方法的查找规则。 // 创建一个学生对象 var stu1 = new Student(); console.log(stu1.constructor) 3、借用继承 本质就是改变父类构造函数中this指向子类(这里使用call方法)，子类调用父类属性 优缺点： 优点：完美继承了属性 缺点：无法继承方法。 3.1 call方法 语法： 函数名.call(调用者,函数实参，函数的实参...); 作用：该函数会立即执行，函数体内的this在被call时，this指向调用者。 代码： 12345678function Person(userName,age) &#123; console.log(this===obj); this.userName = userName; this.age = age; &#125; // 需求：通过一种方式调用执行Person函数，并且函数内部this代表obj var obj = &#123;&#125;; // new Object() Person.call(obj,&#x27;张三&#x27;,10); //==&gt;Person中的this指向obj 3.2 使用call实现借用继承 如何实现： 在子类中，通过call调用父类，并更改父类中this的指向子类对象。 图解： 代码： 1234567891011121314151617181920212223242526// 人类 → 父类 function Person(name,age,gender) &#123; this.name = name; this.age = age; this.gender = gender; &#125; Person.prototype.sayHi = function () &#123; console.log(&#x27;hello&#x27;); &#125;; Person.prototype.eat = function () &#123; console.log(&#x27;eat。。。&#x27;); &#125;; Person.prototype.play = function () &#123; console.log(&#x27;play&#x27;); &#125;; // 学生类 → 子类 function Student(name,age,gender,stuId) &#123; // this关键字代表谁,代表的是一个学生对象，当前创建的对象 stu1 ,stu2 // var obj = this; //【借用继承】 // Person.call(obj,name,age,gender); Person.call(this,name,age,gender); this.stuId = stuId; &#125; // 创建第一个学生对象 var stu1 = new Student(&#x27;张三&#x27;,15,&#x27;男&#x27;,1006); // 创建第二个学生对象 var stu2 = new Student(&#x27;李四&#x27;,16,&#x27;女&#x27;,1005); 3.3 利用apply实现继承(同上) 代码： 12345678910function person(name,age) &#123; this.name = name; this.age = age; &#125; function man(name,age)&#123; person.apply(this,[name,age]); //这里就是伪造成 person 的一个事例 &#125; var Man = new man(&#x27;wozien&#x27;,12); console.log(Man.name); console.log(Man.age); 4、组合继承 如何实现： 原型继承和借用继承同时使用。 代码： 123456789101112131415161718192021222324252627// 人类 → 父类function Person(name,age,gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;Person.prototype.sayHi = function () &#123; console.log(&#x27;hello&#x27;); &#125;;Person.prototype.eat = function () &#123; console.log(&#x27;eat&#x27;); &#125;;Person.prototype.play = function () &#123; console.log(&#x27;play&#x27;); &#125;; // 学生类 → 子类function Student(name,age,gender,stuId) &#123; //【借用继承】 Person.call(this,name,age,gender); this.stuId = stuId;&#125; // 【原型继承】Student.prototype = new Person();Student.prototype.constructor = Student; // 创建第一个学生对象var stu1 = new Student(&#x27;张三&#x27;,16,&#x27;男&#x27;,1006);// 创建第二个学生对象var stu2 = new Student(&#x27;李四&#x27;,15,&#x27;女&#x27;,1005);","path":"2017/04/15/JS中简单的几种继承方法/","date":"04-15","excerpt":"","tags":[{"name":"javascript","slug":"javascript","permalink":"https://diamond-sjh.github.io/tags/javascript/"}]},{"title":"原型","text":"1、了解学习原型的目的 问题：若不用原型，则会产生内存浪费问题。 原因：方法放在构造函数中，每次new时，都会向对象中添加方法。 解决方案：把方法放到原型中，就可以让同类型的对象共享 。 2、什么是原型 原型就是一个对象(系统为函数所分配的一个对象)，原型一直都在。 获取原型： 语法： 构造函数名.prototype 3、构造函数和原型的关系 理论： 构造函数可以通过 prototype 获取到原型 原型可以通过 constructor 找到构造函数 图解： 代码： 12345678910111213141516// 学生类→ 构造函数 function Student(name,age,gender) &#123; // 属性 this.name = name; this.age = age; this.gender = gender; &#125; // 获取原型 // 每一个函数都有一个对应的原型 var yx = Student.prototype; console.log(yx); // 原型是一个对象 // 自带了一个成员：constructor → 构造函数 console.log(yx.constructor === Student); 4、构造函数、实例对象和原型的关系 关系： 构造函数可以通过prototype获取原型 实例对象可通过new关键字调用构造函数创建 实例对象在查找方法时可以通过__proto__ 进入原型中查找 一个对象调用属性和方法的过程： ① 首先，会从对象本身中去找 ② 若对象中，找不到，则会通过__proto__所提供的原型地址，找原型 ③ 去原型中查找。 向原型中添加方法： 语法：原型.key =value; 实例：jQyery中自定义插件； 图解： 代码： 123456789101112131415161718192021222324252627282930// 学生类→ 构造函数function Student(name, age, gender) &#123; // 属性 this.name = name; this.age = age; this.gender = gender;&#125; // 获取原型 ，每一个函数都有一个对应的原型var yx = Student.prototype; // 向原型中添加方法：对象.key = value// 方法1yx.sayHi = function () &#123; // 方法内部：this 代表的是调用方法的对象 console.log(&#x27;我叫什么&#x27; + this.name)&#125;;// 方法2yx.writeCode = function () &#123; console.log(&#x27;我会写code&#x27;);&#125;// 属性yx.type = &#x27;学生&#x27;; // 创建对象var zs = new Student(&#x27;张三&#x27;, 10, &#x27;男&#x27;);// 创建对象var ls = new Student(&#x27;李四&#x27;, 11, &#x27;男&#x27;);// 创建对象var ww = new Student(&#x27;王五&#x27;, 17, &#x27;女&#x27;); 5、原型链 本质上就是一个实例对象访问一个属性或方法的完整过程 理论： ① 对象会先从本身查找相关的属性或方法 ② 若对象本身查找不到。则会通过系统给的__proto__进入原型中查找 ③ 若还查找不到，则通过原型中__proto_进入到原型的原型中查找 图解：","path":"2017/03/27/原型/","date":"03-27","excerpt":"","tags":[{"name":"javascript","slug":"javascript","permalink":"https://diamond-sjh.github.io/tags/javascript/"}]},{"title":"JS中的类和对象,new关键字","text":"1、什么是类 生活中：一类、种类 编程中： 类指的是抽象的名称(构造函数)：例如，狗🐶 class关键字，ES6之前没有类的概念。 在ES3或ES5中通过构造函数 来创建对象 构造函数： 内置的：Object、Date、Array等 自定义：例如，Dog…… 2、什么是对象 生活中：万物皆对象。任何具体的事和物都可以看成对象 编程中：对象由属性和方法组成（或由键值对）。 具体的实例，实例对象 属性：对象的静态特征，例如某人的，姓名、年龄、身高、性别等 方法：对象的功能特征，例如某人，画画、写代码等 注意事项： 方法的值用什么表示，用函数来表示 对象方法中的this，指向调用者。 3、类(构造函数)和对象的关系 类是对象的模板 对象是类的具体实例（通过关键字 instanceof 检测一个对象是否属于某一个类型） 语法：对象名 instanceof 构造函数名; 返回布尔值 创建对象得通过类（构造函数）创建 new 构造函数() → 具体的实例(实例对象) 4、创建对象 语法：自定义构造函数（类） 12345function 构造函数名(行参...)&#123; this.key = value； .......&#125;// 注意规范：构造函数名首字母要大写 帕斯卡（每个单词首字母大写） 驼峰（从第二个单词开始首字母大写） 语法：new关键字创建对象 1var 对象名 = new 构造函数名(实参...); 5、new关键字的执行过程 构造函数在执行时，内部的this指向当前创建的对象 过程： 首先会向内存申请一块空间，存放对象。 this关键字会指向内存中存放对象的空间。（this代表了当前创建的对象） 通过this关键字向内存中的对象中添加属性和方法 会把this返回给外部接收的变量 图解： 代码： 12345678910111213141516171819//构造函数function Student(name,age,gender) &#123; // 属性 this.name = name; this.age = age; this.gender = gender; // 方法 this.sayHi = function() &#123; // 方法内部：this 代表的是调用方法的对象 console.log(&#x27;我叫什么&#x27; + this.name) &#125;; this.writeCode = function() &#123; console.log(&#x27;我会写code&#x27;); &#125;&#125;// 创建对象var zs = new Student(&#x27;张三&#x27;,10,&#x27;男&#x27;);// 使用对象zs.writeCode();","path":"2017/03/20/JS中的类和对象/","date":"03-20","excerpt":"","tags":[{"name":"javascript","slug":"javascript","permalink":"https://diamond-sjh.github.io/tags/javascript/"}]},{"title":"FormData对象","text":"H5新增FormData对象FormData是h5中新增的一个内置对象。 FormData对象用以将数据编译成键值对，以便用XMLHttpRequest来发送数据。其主要用于发送表单数据，但亦可用于发送带键数据(keyed data)，而独立于表单使用。 以前 AJAX 操作只能提交字符串，现在可以提交 二进制 的数据 使用方法一（有form表单） 1234567891011121314151617181920212223242526272829303132&lt;form id=&quot;fm&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; checked&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt; &lt;input type=&quot;file&quot; name=&quot;pic&quot;&gt;&lt;br/&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;script&gt; // 当点击提交按钮的时候，获取表单各项的值，然后将他们发送给服务器 document.getElementById(&#x27;btn&#x27;).onclick = function () &#123; // 获取表单各项的值 /* var user = document.getElementsByName(&#x27;user&#x27;)[0].value; var pwd = document.getElementsByName(&#x27;pwd&#x27;)[0].value; */ // 使用FormData来收集表单数据 // 1. 有表单，找到表单 var form = document.getElementById(&#x27;fm&#x27;); // 2. 实例化FormData，将表单DOM对象传递给FormData var fd = new FormData(form); // fd对象，里面包含了表单中所有的值 // 把fd发送给服务器即可 var xhr = new XMLHttpRequest(); xhr.open(&#x27;POST&#x27;, &#x27;/fd&#x27;); // fd接口专门用于处理FormData类型的数据的 // xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;); xhr.responseType = &#x27;json&#x27;; xhr.send(fd); xhr.onload = function () &#123; console.log(this.response); &#125; &#125;&lt;/script&gt; ==上述使用FormData的时候，form表单中的各项必须有name属性。没有name属性是收集不到数据的== 使用方法二（没有form表单） 123456789101112131415161718192021222324252627282930&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;user&quot;&gt;&lt;br&gt;&lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;pwd&quot;&gt;&lt;br&gt;&lt;input type&#x3D;&quot;file&quot; id&#x3D;&quot;pic&quot;&gt;&lt;br&#x2F;&gt;&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot; value&#x3D;&quot;提交&quot;&gt;&lt;script&gt; &#x2F;&#x2F; 点击提交按钮的时候，收集表单各项的数据，然后将他们发送给fd接口 document.getElementById(&#39;btn&#39;).onclick &#x3D; function () &#123; &#x2F;&#x2F; 1. 没有form，只能先实例化FormData var fd &#x3D; new FormData(); &#x2F;&#x2F; 2. 调用fd提供的append方法，向fd对象中，添加值 &#x2F;&#x2F; fd.append(&#39;key&#39;, &#39;value&#39;); fd.append(&#39;username&#39;, document.getElementById(&#39;user&#39;).value); fd.append(&#39;pwd&#39;, document.getElementById(&#39;pwd&#39;).value); &#x2F;&#x2F; 如果是文件的话，value值必须使用文件对象 &#x2F;&#x2F; 获取文件对象 &#x2F;&#x2F; console.dir(document.getElementById(&#39;pic&#39;)); var fileObj &#x3D; document.getElementById(&#39;pic&#39;).files[0]; &#x2F;&#x2F; fd.append(&#39;myfile&#39;, 文件对象); fd.append(&#39;myfile&#39;, fileObj); var xhr &#x3D; new XMLHttpRequest(); xhr.open(&#39;POST&#39;, &#39;&#x2F;fd&#39;); xhr.responseType &#x3D; &#39;json&#39;; xhr.send(fd); xhr.onload &#x3D; function () &#123; console.log(this.response); &#125; &#125;&lt;&#x2F;script&gt; jQuery中使用FormData： 123456789101112131415161718192021222324252627282930313233343536373839&lt;form id=&quot;fm&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; checked&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt; &lt;input type=&quot;file&quot; name=&quot;pic&quot;&gt;&lt;br /&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;script src=&quot;/jquery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&#x27;#btn&#x27;).click(function () &#123; var fm = $(&#x27;#fm&#x27;); var fd = new FormData(fm[0]); // 这里fm必须是DOM对象 console.log(fd); $.ajax(&#123; type: &#x27;post&#x27;, url: &#x27;/fd&#x27;, // 如果data使用的是对象，ajax方法会把对象转成字符串， // 即把&#123;name: &#x27;zs&#x27;, age: 18&#125;转成name=zs&amp;age=18 // data: &#123;name: &#x27;zs&#x27;, age: 18&#125;, data: fd, // processData: false, 表示不让jQuery把fd对象转成字符串，而是直接发送fd对象 processData: false, // contentType：false，表示不让jQuery去设置content-type，让FormData去处理 contentType: false, success: function (res) &#123; console.log(res); &#125; &#125;); &#125;); // xhr.send(&#x27;name=zs&amp;age=18&#x27;); &lt;/script&gt; 参考链接： https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects","path":"2017/01/28/FormData对象/","date":"01-28","excerpt":"","tags":[{"name":"H5","slug":"H5","permalink":"https://diamond-sjh.github.io/tags/H5/"}]},{"title":"正则表达式","text":"1、正则表达式 特点： 灵活性、逻辑性和功能性非常的强 可以迅速地用极简单的方式达到字符串的复杂控制 特点： 给定的字符串是否符合正则表达式的过滤逻辑(匹配) 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取) 强大的字符串替换能力(替换) 1.1 什么是正则表达式​ 正则表达式Regular Expression：正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 ​ 正则表达式在其他语言中也广泛应用。 正则表达式，就是定义好一个字符串规则 ，然后根据规则实现对象字符串的匹配、提取、替换等 1.2 正则表达式语法1.2.1 正则表达式的组成 普通字符abc 123 我爱你 特殊字符(元字符、限定符、中括号)：正则表达式中有特殊意义的字符 1.2.2 元字符​ 元字符就是，在正则表达式中具有特殊含义的字符。 元字符 说明 \\d 匹配数字 \\D 匹配非数字 \\w 匹配字母或数字或下划线_ \\W 匹配非字母、数字、下划线_ \\s 匹配空白符（空格） \\S 匹配非空白符 . 匹配任意除了回车换行符之外的单个字符 1.2.3 限定符控制字符出现的个数。 限定符 说明 n* 匹配任何包含零个或多个 n 的字符串。n{0,}。 若找到最后，字符串后面没有任何东西也算符合。 若有符合正则值，按照最多的匹配。 n+ 匹配任何包含至少一个 n 的字符串。{1,} 。 n? 匹配任何包含零个或一个 n 的字符串。{0,1} 若找到最后，字符串后面没有任何东西也算符合。若有符合正则值，按照1个匹配 n{x} 匹配包含 x 个 n 的序列的字符串 n{x,} 匹配包含至少 x 个 n 的序列的字符串。 n{x,y} 匹配包含 至少x个 至多 y 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串 ^n 匹配任何开头为 n 的字符串 注意： ==^正则表达式$== 使用时，会对字符串整体校验，完全符合才能够匹配。否则，不匹配。 在使用花括号限制字符个数时，将来在去匹配时，首先从前向后匹配，先按照至多的要求匹配，至多不满足时，再降低要求匹配，若将至最少时还不匹配→ 最终是不匹配。 关于次数至少是0时，表示的有没有都符合。 没有符合，内容不是也符合 1.2.4 中括号一个中括号就代表一个字符，中括号的目的就是控制了一个字符的范围。 对象字符种类限制 中括号 说明 [abc] 查找一个方括号之间的任何字符。 [ ^abc] 查找一个任何不在方括号之间的字符。^在中括号中有取反的意思 [0-9] 查找一个任何从 0 至 9 的数字。 [a-z] 查找一个任何从小写 a 到小写 z 的字符。 [A-Z] 查找一个任何从大写 A 到大写 Z 的字符。 [A-z] 查找一个字母（包含大小写和下划线） [\\u4e00-\\u9fa5] 查找一个汉字 ​ 在匹配时，从前向后按照【规则】去找，若是全局匹配，前面若有满足项时，后面再匹配时，从满足项下一个开始匹配。 1.2.5 或模式特殊符号：正则1|正则2, 或者。 符合或两边其中一个就可以匹配。 如：google，baidu，bing; // 匹配三种其中一种字符串 正则：google|baidu|bing 1.2.6 分组模式特殊符号：**(正则)**; 组指的是一个小集体，分组就是将一个大集体可以分成几个小集体。 如：控制bruce连续出现的次数，最少1次，最多3次 正则：^(bruce){1,3}$ 1.2.7 修饰符→ g g，全称global，有 全局 的意思，表示全局匹配。 如： var reg = /hello/g;→ i i，全称ignore，有 忽视、忽略 的意思，表示匹配字母时，可以忽略字母的大小写。​ 如： var reg = /hello/i; → gi ig gi，全局匹配和忽略大小写一起使用。 如： var reg = /hello/gi; 1.2.8 正则转义符“.”在正则中表示特殊符号。去除.的特殊意义，需要转义： \\ . 1.3 js中使用正则表达式1.3.1 正则表达式对象 创建正则表达式对象 方式1： 语法：var 变量 = new RegExp(“规则”,”修饰符”); 代码： 1var reg = new RegExp(&#x27;\\\\d&#x27;,&#x27;g&#x27;); 方式2：字面量或直接量 语法：var 变量 = /正则表达式/; 代码： 1var reg = /\\d/g; 检测匹配 正则对象.test(字符串) ; 用于检测字符串是否匹配某个规则。返回true和false。 1.3.2 字符串对象方法相关正则使用 字符串.match(正则对象); 提取所有匹配的内容获取匹配正则的子字符串，返回一个数组。 字符串.replace(正则对象,替换后的内容);​ 替换所匹配正则的子字符串。返回替换后的字符串。","path":"2016/12/28/正则表达式/","date":"12-28","excerpt":"","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://diamond-sjh.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"git的push端口错误解决","text":"出现的问题：Git Bash 控制行命令： git push 向远程git仓库ssh地址推送的时候，命令行提示Connection reset by 52.74.223.119 port 22，而git push 向远程git仓库http地址推送的时候正常推送 问题如图所示： 解决的方法：在window防火墙设置22端口1、window10安全中心–&gt;高级设置 2、入站规则–&gt;新建规则 3、选择端口 4、端口输入22 5、选择允许连接 6、下一步 7、添加名称和描述（随意填写）","path":"2016/11/20/git的push端口错误解决/","date":"11-20","excerpt":"","tags":[{"name":"git","slug":"git","permalink":"https://diamond-sjh.github.io/tags/git/"}]},{"title":"git基础","text":"1、git和github是什么？git是一个工具（软件），github是一个代码托管平台，类似的还有码云 作用：我们可以在自己的电脑上通过git这个软件从github上下载（拉取）代码，也可以将我们本地电脑上的代码上传到github上。 2、github账号的注册：1.打开github官网：https://github.com 2.填入自己的信息，完成注册之后，登录(Sign in)上就ok了。 3、git的安装：1、根据自己电脑情况，选择应该安装的软件。 2、下载地址：https://git-scm.com/downloads 3、一路next安装即可。 4、在命令行中输入以下命令查看 Git 是否安装成功。 123$ git --version# 如果看到类似 git version 2.21.0.windows.1 ，表示安装成功了 5、安装完成之后，在电脑任何一个位置，点击鼠标右键，会多了两个选项： ​ – Git GUI Here ​ – Git Bash Here Git GUI Here 的作用是，在此创建一个可视化的git窗口，用来上传或拉取代码或其他操作 Git Bash Here 的作用是，在此创建一个git命令行窗口，用来上传或拉取代码或其他操作 6、我们经常使用的是Git Bash Here 这个命令行窗口，在里面输入一些命令就可以进行操作。 4、使用Git管理自己的代码 初次使用Git，会让我们配置用户的信息，配置方式如下： 123# --global 会将配置项保存到用户配置$ git config --global user.name &quot;xxx&quot;$ git config --global user.email &quot;xxx&quot; 4.1 git名词解读：Workspace : 工作区 工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 Index / Stage : 暂存区 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’’，不过一般说法还是叫暂存区域。 Repository ： 仓库区（本地仓库） Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 Remote ： 远程仓库 工作区新建的文件和Git没有任何关系；文件被添加到暂存区，才叫做被Git管理过 代码不能越过暂存区而直接从工作区提交到仓库区 Untracked files：未跟踪 表示还没有被 Git 管理过，既没有进入过暂存区，更没有进入过仓库区。 staged：已暂存 表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 committed：已提交 表示数据已经安全的保存在本地数据库中。 modified：已修改 表示修改了暂存区的文件，但还没提交到仓库区。 4.2 git常用命令：git clone 仓库地址 — 用来从远程仓库（github）上克隆项目 git init —- 初始化（新建仓库区（本地仓库）），在本地电脑的一个文件夹中执行此命令，会生成一个叫.git的隐藏文件夹 git pull 仓库地址 —– 用来从远程仓库中下载代码 和clone很相似 git add . —– 将本地项目中新增、修改的文件添加到暂存区中，注意，后面是个英文状态下的点符号 git commit -m ‘描述’ —— 提交暂存区的代码到仓库区（本地仓库），并添加将要提交的描述 git push 仓库地址 —– 将暂存区的代码上传到远程仓库（github）中 4.3 进阶命令：状态操作：gitk —- 查看状态 git status —- 显示有变更的文件 git log —- 显示当前分支的版本历史 git log –oneline —- 简略查看历史版本 分支操作：git branch —- 查看当前分支 （默认是master分支 – 主分支） git branch 分支名 —– 创建一个分支（注意：目前我们创建分支，必须在master分支上去创建） git checkout 分支名 —- 切换分支 git checkout -b 分支名 —- 创建并切换分支 git merge 分支名 —- 将你想要合并的分支合并到当前分支上 git push origin 【空格】【冒号】【需要删除的分支名字】—通过代码删除远程分支 撤销操作：git checkout [file] —- 恢复暂存区的指定文件到工作区 git checkout . —- 恢复暂存区的所有文件到工作区 git checkout [commit] [file] —- 恢复某个commit的指定文件到暂存区和工作区 git reset [file] —- 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变 git reset –hard —- 重置暂存区与工作区，与上一次commit保持一致 拉取和更新：git pull —- 拉取远程代码到当前分支，并和本地分支合并 git pull [remote] [branch] —- 取回远程仓库的变化，并与本地指定分支合并 需要注意的是，我们平时在实际工作中，是不允许对主分支的东西进行操作的，也千万不要对主分支进行合并、提交、更新等。我们需要创建另外一个分支（测试分支），然后在这个分支中去合并其他组员的分支，最终将测试分支中的代码放到服务器上去测试、运行 4.4 示例：仓库地址示例：&#103;&#x69;&#116;&#64;&#x67;&#105;&#116;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#109;:AIMIYue.git / https://gitee.com/ityuer/test.git 组长和组员需要执行以下命令： 1.git clone &#103;&#105;&#116;&#64;&#103;&#105;&#116;&#104;&#x75;&#98;&#46;&#x63;&#111;&#x6d;:AIMIYue.git —- 克隆项目（拉取代码，虽然没什么代码） 2.git branch — 查看分支 3.git branch zhangsan 、git branch lisi 、 git branch wangwu — 创建以自己姓名命名的分支，好区分 4.git branch — 再次查看分支 看有没有创建成功。绿色的是当前的分支，白色的是未被选中的其他分支 5.git checkout zhangsan — 切换到自己的分支，这里是切换到了张三的分支上 6.测试下看能不能在自己的分支上提交代码，在你的文件夹中新建一个文件，然后执行第七步 7.git add . — 将自己创建、修改、删除的文件添加到暂存区 8.git commit -m ‘first comit’ —- 进行提交（提交到本地仓库），并写上提交信息 9.git push &#x67;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;:AIMIYue.git — 上传代码，上传完成后去github上刷新查看有没有自己的分支及自己的代码 10.如果成功的话，那么接下来就可以进行代码开发了，自己不断的写代码，写完了之后执行上述步骤（从第五步开始） 11.项目开发完成后，组长需要新建分支，然后合并自己和其他组员的分支，命令见下一步 git branch dev —- 创建测试分支，用来合并代码 git checkout dev — 切换到dev分支上 git merge origin/zhangsan 、 git merge origin/lisi 、 git merge origin/wangwu — 合并远程分支 git add. — 添加到暂存区 git commit -m ‘测试分支提交’ — 提交测试分支 git push &#103;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#104;&#117;&#98;&#46;&#99;&#x6f;&#x6d;:AIMIYue.git — 将测试分支上传到仓库中 此时，项目已经完成，各组员可以各自从dev分支上拉取代码，然后运行就可以了 4.5 注意事项：1.当创建完分支后，远程仓库不会有分支（因为此时创建的是本地分支），需要切换到新创建的分支，然后进行一次代码提交，远程仓库才会有你新创建的分支 2.进行代码提交，必须按照严格的顺序执行命令，不允许颠倒(add–&gt;commit–&gt;push) 3.每次add之前，要先看一下你目前处于哪个分支，可使用git branch查看，在命令行中的每句话末尾也都会有分支标识 4.如果不小心add了，发现分支错了，或者不小执行了add命令，需要使用 git rm –cached 文件名 命令将add的文件从缓存区中删除。也可以使用 git rm -r –cached 文件名 命令删除某一个文件夹下的文件 5.创建并切换分支可以合并为一个命令，例如：git checkout - b zhangsan 6.可以使用git status 来查看发生变动的文件 7.小组项目的分支创建，一定要在master分支上去创建其他的分支！ 关于更为详细的git的其他命令，可点击下方链接： 链接：http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html https://www.liaoxuefeng.com/wiki/896043488029600 layui：https://www.layui.com/ layer：http://layer.layui.com/ JQUI：https://www.jqueryui.org.cn/tutorial/27.html","path":"2016/10/28/git基础/","date":"10-28","excerpt":"","tags":[{"name":"git","slug":"git","permalink":"https://diamond-sjh.github.io/tags/git/"}]}],"categories":[],"tags":[{"name":"app","slug":"app","permalink":"https://diamond-sjh.github.io/tags/app/"},{"name":"vue","slug":"vue","permalink":"https://diamond-sjh.github.io/tags/vue/"},{"name":"javascript","slug":"javascript","permalink":"https://diamond-sjh.github.io/tags/javascript/"},{"name":"H5","slug":"H5","permalink":"https://diamond-sjh.github.io/tags/H5/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://diamond-sjh.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"git","slug":"git","permalink":"https://diamond-sjh.github.io/tags/git/"}]}