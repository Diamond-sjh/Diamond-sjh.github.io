{"meta":{"title":"Diamond","subtitle":"我走的很慢,但是我从来不会后退","description":null,"author":"Mr.sun","url":"http://diamond-sjh.github.io","root":"/"},"pages":[{"title":"search","text":"","path":"search/index.html","date":"09-29","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"09-29","excerpt":""}],"posts":[{"title":"Vue Router","text":"路由router什么是路由组件切换是通过变换url地址的锚点信息而显示不同的组件，路由也是如此，也是 浏览器地址信息 与 组件 的映射关系体现，但路由是组件切换SPA的封装版本，使用起来要更加方便、高效 官网参考 上图 浏览器锚点发生变化，会被onhashchange感知 然后window.location.hash获得变换后的锚点信息 通过锚点获得用于显示组件的标签名称 标签名称赋予给component标签的is属性 组件就呈现 以上锚点找到对应组件的过程就是路由 路由对 component标签、onhashchange、window.location.hash、等原始内容做了封装，是更高级组件切换的体现 在 vue 中使用 vue-router安装路由vue-router路由是一个js功能模块，在使用的时候需要先安装 运行指令 1yarn add vue-router 应用路由 在入口文件处导入路由模块(index.js) 1import VueRouter from 'vue-router' 注册路由模块(index.js) 把导入的路由模块注册给Vue Vue.use(xxx)就是要把某个功能模块注册给Vue， 该操作类似通过Vue.component()方式给Vue注册组件， 注册多个组件需要多次执行Vue.component()，而Vue.use()可以一次性注册全部的组件，使用更给力，其本身也有其他功能，后续会介绍。 1Vue.use(VueRouter) 导入要显示组件(index.js) 把要显示的子级组件导入进来 123import Home from './home.vue';import About from './about.vue';import Movie from './movie.vue'; 事先把对应的 home.vue、about.vue、movie.vue子组件和内容创建好 创建路由对象(index.js)创建路由对象，并把hash和组件的对应关系设置好 12345678const router = new VueRouter(&#123; // 配置对象中，要提供 hash 地址 到 组件之间的 对应关系 routes: [ // 这个 routes 就是 路由 规则 的数组，里面要放很多的对应关系 // &#123; path: 'hash地址', component: 组件对象 &#125; &#123; path: '/home', component: Home &#125;, &#123; path: '/user', component: Movie &#125;, &#123; path: '/about', component: About &#125; ]&#125;) 挂载路由(index.js)把创建好的 router 对象，挂载到 主vm 对象上 12345const vm = new Vue(&#123; el: '#app', render: c =&gt; c(App), router // 把 创建的路由对象挂载到 VM 实例上，与 router:router 效果一致&#125;) 创建路由链接(App.vue) 在主vue组件中，通过router-link方式应用超链接 router-link标签：用以创建 路由的 hash锚点 超链接 to 属性，表示 点击此链接，要跳转到哪个 hash锚点 请求地址 123&lt;router-link to=\"/home\"&gt; 首页 &lt;/router-link&gt;&lt;router-link to=\"/user\"&gt; 会员 &lt;/router-link&gt;&lt;router-link to=\"/movie\"&gt; 电影 &lt;/router-link&gt; to 属性中，不需要以 # 开头 router-link编译后会变成具体的html标签效果： 设置容器(App.vue) 在App.vue根组件中通过router-view标签设置显示组件的容器 1&lt;router-view&gt; &lt;/router-view&gt; router-view的作用类似于component标签，设定占位符，用以显示各个业务子组件 路由规则的匹配过程： 用户点击 页面的 路由链接router-link，点击的一瞬间，就会修改 浏览器 地址栏 中的 Hash 锚点地址信息， 当 hash 信息被修改以后，会立即被 路由 监听到 (路由有封装onhashchange事件) 在onhashchange事件里边感知变化后的hash锚点信息(window.location.hash)，然后与对应的组件进行联系 组件被显示，具体是通过路由占位符rouer-view进行显示 redirect重定向用户第一次访问网站页面(“/根目录”首页)时，地址栏里边没有“hash锚点”的信息，也就没有对应的组件用于显示，明显项目体验不好，现在可以通过redirect实现重定向效果即 设定“/根目录”与一个具体路由联系起来，这样即使浏览器地址栏没有任何锚点信息，也有默认的组件进行显示 使用示例： 123456const router = new VueRouter(&#123; routes:[ &#123;path:'/', redirect: '/mv'&#125;, &#123;path:'/mv', component: Movie&#125;, ]&#125;) 当访问”/根目录”时，就重定向到”/mv锚点”，进而显示Movie组件 路由按钮高亮官网参考 在App.vue主页面中(router-link超链标签使用页面)通过router-link-active选择器设置如下样式： 123&lt;style lang=\"less\" scoped&gt;.router-link-active &#123;background-color: lightgreen;&#125;&lt;/style&gt; 当前超链按钮被单击选中会有浅绿背景颜色高亮显示 被点击激活的按钮，本身有class属性值，直接进行css样式设定即可： 嵌套路由（子路由）路由的应用是在App.vue根组件中通过单击超链按钮切换显示不同子组件，具体表现就是父、子组件嵌套关系 有的应用比较复杂，子组件内部还有子组件，形成了 1级App.vue组件–&gt;2级业务组件–&gt;3级业务组件 的效果，现在学习如何在 2级组件 中切换显示 3级组件 使用步骤： 在2级组件中设置 切换标签 和 显示的组件容器 1234&lt;router-link to='/music/hongkong'&gt;香港&lt;/router-link&gt;&lt;router-link to='/music/taiwan'&gt;台湾&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt; router-link：设置超链按钮 router-view：第3级组件显示的容器 在对应的路由规则中，通过 children 属性，定义子路由规则： 12345678910111213141516var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/user' &#125;, &#123; path: '/home', component: Home &#125;, &#123; path: '/user', component: User &#125;, &#123; path: '/movie', component: Movie, children: [ &#123; path: '/movie/hongkong', component: Hongkong &#125;, &#123; path: '/movie/taiwan', component: Taiwan &#125;, &#123; path: '/movie/dalu', component: Dalu &#125; ] &#125; ]&#125;) 重定向 如果需要redirect重定向效果可以像如下两种方式设置，任选一个即可： 123456789101112131415161718var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/user' &#125;, &#123; path: '/home', component: Home &#125;, &#123; path: '/user', component: User &#125;, &#123; path: '/movie', component: Movie, redirect: '/movie/hongkong', // 1) 方式重定向 children: [ &#123; path: '', redirect:'/movie/hongkong' &#125;, // 2) 方式重定向 &#123; path: '/movie/hongkong', component: Hongkong &#125;, &#123; path: '/movie/taiwan', component: Taiwan &#125;, &#123; path: '/movie/dalu', component: Dalu &#125; ] &#125; ]&#125;) 重定向注意： 方式1 设置redirect成员的同时也需要component成员 路由传参使用步骤： 在路由中设定参数 1234567891011const router = new VueRouter(&#123; routes:[ &#123; path: '/music, component: Music, children: [ &#123;path:'/dt/:mid', component: Detail, props:true&#125; ] &#125; ]&#125;) :mid 表示当前路由有一个参数，名称为mid, :冒号 是必须的(需要时可以通过相同的方式声明多个参数)props:true 表示当前路由有参数需要传递 在router-link超链地方把需要的参数设置好 1&lt;router-link :to=\"/dt/1001\"&gt;XXX&lt;/router-link&gt; 通过to属性对“参数”一并进行设置 router-link默认生成a标签，如果想生成其他标签，可以通过如下方式实现 1&lt;router-link tag=\"li\" :to=\"/dt/1001\"&gt;XXX&lt;/router-link&gt; tag=”li” 表示生成li标签，并且超链效果仍然有效，可以参考 参数的接收和使用 1234567&lt;p&gt;电影详情展示---&#123;&#123; mid &#125;&#125;&lt;/p&gt;&lt;script&gt;export default &#123; // 通过props接收的路由参数信息，名称为mid props:['mid']&#125;&lt;/script&gt; 要通过props对路由参数进行接收 props对两种数据都可以接收： 1) 路由参数 2) 父组件给传递过来的数据 编程式导航导航：一个路由切换到另外一个路由去(/mv /dt/102) 什么是router-link是通过静态超链接按钮的方式把各个用于显示的组件给声明好，单击哪个按钮就显示哪个组件，其被称为声明式导航 有时并不能通过单击超链按钮来显示一个组件，例如判断用户是登录状态就显示业务组件页面，否则显示登录组件页面，这时需要通过程序代码实现组件的判断显示，通过编写程序代码的方式实现组件显示就称为编程式导航 使用语法1234this.$router.push(路由地址) // 根据路由信息显示组件,可以是router-link标签的to属性值this.$router.go(n) // n可以是 负数、0、正数，表示页面要 回退、刷新、前进 this.$router.forward() // 前进this.$router.back() // 后退 灵感来自bom浏览器对象模型 window.history.go() window.history.back() window.history.forward() 官网参考 路由守卫路由对象有一个名称为beforeEach的方法，每个路由在加载组件之前都要调用它，在这个方法中可以做逻辑判断，限制要做什么或不做什么，这个过程称为路由守卫，有着一夫当关万夫莫开的效果 ​ 语法1router.beforeEach((to, from, next) =&gt; &#123; /* 导航守卫 处理逻辑 */ &#125;) 这里的 router 就是 new VueRouter 得到的 路由对象 beforeEach()是路由在显示组件之前要执行的代码 参数1 to:是一个对象，保存着将要访问路由相关的参数 from:是一个对象，保存着离开的那个页面的相关路由参数 next:是一个函数，对后续的执行起着 拦截 或 放行 的作用 如果没有问题请一定执行next()方法，以进行后续操作， next()方法也可以通过传递路由信息实现其他组件的显示 例如：next(‘/login’) 显示登录组件","path":"2018/12/15/Vue-Router/","date":"12-15","excerpt":"","tags":[{"name":"vue","slug":"vue","permalink":"http://diamond-sjh.github.io/tags/vue/"}]},{"title":"vue生命周期","text":"vue生命周期什么是生命周期 定义：生命周期是指vue实例(或者组件)从诞生到消亡所经历的各个阶段的总和 生命周期： vue在使用的过程中，分为多个阶段，具体有创建、运行、销毁，并且可以通过成员方法感知到 创建阶段由空白期、data初始化、methods初始化、模板渲染等组成 运行阶段分为 更新前 和 更新后 两部分 销毁阶段分为 销毁前 和 销毁后 不同阶段完成不同的任务，开发者可以利用各个阶段的特点完成业务需要的相关功能 beforeCreate：可以在这加个loading事件，在加载实例的时候触发 created：初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted：挂载元素，获取到DOM节点 updated：如果对数据同意处理，在这里写上相应函数 beforeDestroy：可以做一个确认停止事件的确认框 生命周期参考 生命周期函数分类创建阶段 创建期间的生命周期函数：(特点：每个实例一辈子只执行一次，并且是自动的) beforeCreate：创建之前，此时 data 和 methods 尚未初始化 created : 第一个重要的函数，此时，data 和 methods 已经创建好了，可以被访问，在此处非常适合做data数据初始化操作 beforeMount：挂载容器模板结构之前，此时，容器的内容已经被Vue获取到了(容器本身还是未解析的原始内容)； 现在Vue实例就被称为 Virtual DOM(虚拟DOM) mounted 第二个重要的函数，此时，容器被vue渲染解析完毕；是操作初始DOM元素的最好时机 123456beforeCreate() &#123; console.group('---------beforeCreate调用--------') console.log('%c%s', 'color:red', 'el现在的样子：' + this.$el) // undefined console.log('%c%s', 'color:red', 'data现在的样子：' + this.$data) // undefined console.log('%c%s', 'color:red', 'methods方法现在的样子：' + this.getInfo) // undefined&#125; console.group() 按照组别对调试信息进行划分 %c: 给调试信息设置样式，通过log的第2个参数体现 $s: 通过string字符串方式输出信息，通过log的第3个参数体现 this.$el: 获得到与Vue实例关联的容器 this.$data: 获得data全部的成员，以对象形式返回 this.getInfo: 把methods成员方法当做普通变量获取输出 123456created() &#123; console.group('---------created调用--------') console.log('%c%s', 'color:red', 'el现在的样子：' + this.$el) // undefined console.log('%c%s', 'color:red', 'data现在的样子：' + this.$data) // 实体 console.log('%c%s', 'color:red', 'methods方法：' + this.getDate) // 实体&#125; &gt; 在此函数中适合进行Vue数据初始化(获取首屏数据)操作 12345beforeMount() &#123; console.group('---------beforeMount调用--------') console.log('%c%s', 'color:red', 'el现在的样子：' + this.$el) // 实体 console.log(this.$el) // 编译【前】的实体内容&#125; 12345mounted() &#123; console.group('---------mounted调用--------') console.log('%c%s', 'color:red', 'el现在的样子：' + this.$el) // 实体 console.log(this.$el) // 编译【后】的实体内容&#125; &gt; 此时适合对页面dom元素做初始化操作运行阶段 运行期间的生命周期函数：（特点：按需被调用 至少0次，最多不限制） beforeUpdate：根据最新的数据重新解析渲染浏览器页面，此时 vue虚拟数据是最新的，但是页面还是旧的 updated：页面和数据都是最新的页面已经完成了更新，此时data数据和页面都是最新的 12345678beforeUpdate() &#123; console.group(&apos;---------beforeUpdate调用--------&apos;) console.log( &apos;%c%s&apos;, &apos;color:red&apos;, &apos;h2数据更新之前的效果：&apos; + document.querySelector(&apos;h2&apos;).innerHTML )&#125; 12345678updated() &#123; console.group(&apos;---------updated调用--------&apos;) console.log( &apos;%c%s&apos;, &apos;color:red&apos;, &apos;h2数据更新之后的效果：&apos; + document.querySelector(&apos;h2&apos;).innerHTML )&#125; 有 “Virtual DOM(虚拟DOM)”，其是Vue实例获取到的div容器，是虚拟的(不是页面实实在在看到的)，该VirtualDOM 在Vue的生命周期运行阶段始终存在，随时感知数据变化，随时同步给页面 销毁阶段 销毁期间的生命周期函数：(特点：每个实例一辈子只执行一次) beforeDestroy：将要销毁，处于销毁之前阶段，实例还正常可用 destroyed：销毁之后，Vue实例已经不工作了 1234beforeDestroy() &#123; console.group(&apos;---------beforeDestroy调用--------&apos;) console.log(&apos;%c%s&apos;, &apos;color:red&apos;, &apos;el现在的样子：&apos; + this.$el)&#125;, 1234destroyed() &#123; console.group(&apos;---------destroyed调用--------&apos;) console.log(&apos;%c%s&apos;, &apos;color:red&apos;, &apos;el现在的样子：&apos; + this.$el)&#125; 完整应用示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--创建一个div容器，vue对该容器进行控制，设置要显示的内容--&gt; &lt;div id=\"app\"&gt; &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"./vue-2.6.10.js\"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; // 1) 生命周期创建阶段(4个函数),会自动执行 beforeCreate()&#123; // Vue实例已经创建完毕，但是相关的成员都没有，el、methods、data等等都没有 console.group('--------beforeCreate发生调用--------') console.log('%c%s','color:red','el现在的样子：'+this.$el) // undefined console.log('%c%s','color:red','data现在的样子：'+this.$data) // undefined console.log('%c%s','color:red','getDate现在的样子：'+this.getDate) // undefined &#125;, created()&#123; // 该阶段是一个【重要】阶段，此时data 和 methods已经准备好了，但是还没有去找div容器 // 此阶段可以用于页面首屏数据获取操作，获取回来的数据存储给data的某个成员即可 console.group('--------created发生调用--------') console.log('%c%s','color:red','el现在的样子：'+this.$el) // undefined console.log('%c%s','color:red','data现在的样子：'+this.$data) // 实体 console.log('%c%s','color:red','getDate现在的样子：'+this.getDate) // 实体 &#125;, beforeMount()&#123; // 此阶段完成了Vue实例对象 与 div容器联系的过程(本质是div容器已经被Vue实例获取到了) // 但是div容器的内容还是没有编译前的原生内容 console.group('--------beforeMount发生调用--------') console.log('%c%s','color:red','el现在的样子：'+this.$el) // 实体 console.log(document.getElementsByTagName('h2')[0]) // &#125;, mounted()&#123; // 此阶段 Vue实例已经完成了div容器的内容的编译，并且编译好的内容也渲染给div容器了 console.group('--------mounted发生调用--------') console.log('%c%s','color:red','el现在的样子：'+this.$el) // 实体 console.log(document.getElementsByTagName('h2')[0]) // 容器编译【后】实体内容 &#125;, // 2) 生命周期运行阶段(2个函数),data数据变化后才会执行 beforeUpdate() &#123; console.group('---------beforeUpdate调用--------') console.log( '%c%s', 'color:red', 'h2数据更新【前】的效果：' + document.querySelector('h2').innerHTML ) &#125;, updated() &#123; console.group('---------updated调用--------') console.log( '%c%s', 'color:red', 'h2数据更新【后】的效果：' + document.querySelector('h2').innerHTML ) &#125;, // 3) 生命周期销毁阶段(2个函数),只有vm调用$destroy()方法后才执行 beforeDestroy() &#123; console.group('---------beforeDestroy调用--------') console.log('%c%s', 'color:red', 'el现在的样子：' + this.$el) &#125;, destroyed() &#123; console.group('---------destroyed调用--------') console.log('%c%s', 'color:red', 'el现在的样子：' + this.$el) &#125;, el: '#app', data: &#123; msg: '生命周期学习篇' &#125;, methods: &#123; getDate()&#123; console.log('Sunday') &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 小结：生命周期创建阶段的created和mounted两个函数最经常使用，其他了解即可 created：一般用于页面首屏data数据初始化使用 mounted：可对渲染完毕的页面做dom初始化操作(例如给dom元素设置事件)","path":"2018/11/28/vue生命周期/","date":"11-28","excerpt":"","tags":[{"name":"vue","slug":"vue","permalink":"http://diamond-sjh.github.io/tags/vue/"}]},{"title":"回调函数闭包递归","text":"1、函数作为函数参数(回调函数) 现象：把一个函数B当做实参，传递给另一个函数的A的形参，并在函数A内部调用 参数： 形参：函数定义时，小括号中的标识符 实参：函数调用时，小括号中实际的数据 关系：实参代表的实际数据传递给函数内部的形参使用。 应用场景：当外部向函数内部传入数据时。 代码： 123456789101112// 定义函数A// v是形参function A(v) &#123; v(11,22);&#125;// 调用A( // 函数B function (a,b) &#123; console.log(a + b); &#125;); 图解： 1.2 函数作为函数的返回值 关键字：return 数据; 应用：函数内部要把结果暴露给外部时使用返回值 代码： 123456789// 【返回值是函数时】 function fn() &#123; return function()&#123; console.log('我是内部的的函数'); &#125;; &#125; // 调用函数 var r = fn(); r(); 图解： 3、闭包 变量的生命周期：什么时候在内存中被释放 全局变量的生命周期：程序关闭。 局部变量的生命周期：函数执行结束后。 作用域： 内层 可以 访问 外层，反之不行 闭包的作用： 目的延长局部变量的生命周期 维护私有变量-局部变量的安全 GC（Garbage Collection）垃圾回收机制 回收没有用的数据。 有用的数据：被全局中操作的变量。 闭包的概念： MDN：闭包是函数和声明该函数的词法环境的组合。 百度百科： ​ 闭包(Closure)就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的==桥梁==。 总结：桥梁 代码： 12345678910// 生活：藏在别墅中的三儿，被外部的朝阳群众操作了。 function bieShu () &#123; var a = '三儿'; // 局部变量 var guanJia = function() &#123; console.log(a); // 操作了外部的局部变量 &#125;; return guanJia; // 返回了子函数的地址 &#125; var cyqz = bieShu(); // 接收了子函数的地址 cyqz(); 图解： 如何检测一个程序是否存在闭包 外层函数 和 子函数 外层函数必须有局部变量 子函数要操作外层函数的局部变量 让子函数和外部产生关联（关联不一定是返回函数） 或者， 浏览器F12打开开发者工具 点到 Sources 一栏 打开html文档 在子函数内部设置断点，刷新 检查右边的 Scope 存在Closure即存在闭包 4、递归 递归的优点：减少代码量 递归的缺点：消耗内存，内存栈溢出,报错！ 4.1 什么是递归 函数调用自身的编程技巧。 官方概念 程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量** 。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有==边界条件== 、==递归前进段== 和==递归返回段== 。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。 4.2 递归的三个阶段 递归前进段 递归边界条件 递归返回段 案例： 例子1– –如：一组有规律的年龄10 、12、14、16、18、20、22、24……，求第n个人的年龄 123456789101112131415161718192021222324252627282930// 规律：第n个人的年龄 = 第n-1个人的年龄 + 2// 创建一个函数function age(n) &#123; if(n==1) &#123; return 10; &#125;else &#123; return age(n-1) + 2; &#125;&#125;// 调用var r = age(5); // 若fn的形参超过一定数值，会导致内存栈溢出报错。如：age(5000)，系统会报错console.log(r); // 运行过程如下// -------------------------递归前进段// age(5) // 等待...// age(4) + 2 // 等待...// age(3) + 2 // 等待...// age(2) + 2 // 等待...// age(1) + 2// age(1) 10 // -------递归边界条件// -------------------------递归返回段// age(2) 12// age(3) 14// age(4) 16// age(5) 18 例子2– –如：一组有规律的数字1、1、2、3、5、8、13….，求第n个数字 123456789101112// 规律：第n个数字的结果 = 第n-1个数字的结果 + 第n-2个数字的结果function fn(n) &#123; if(n==1||n==2) &#123; return 1; &#125;else &#123; return fn(n-1) + fn(n-2); &#125;&#125;var r = fn(30); // 若fn的形参超过一定数值，会导致内存栈溢出报错。如：fn(3000)，系统会报错console.log(r);","path":"2017/06/15/回调函数闭包递归/","date":"06-15","excerpt":"","tags":[{"name":"javascript","slug":"javascript","permalink":"http://diamond-sjh.github.io/tags/javascript/"}]},{"title":"浅拷贝和深拷贝","text":"1、浅拷贝和深拷贝 拷贝：对象之间的拷贝。 一个对象拷贝另一个对象中成员 1.1 浅拷贝 浅拷贝：针对赋值数据成员，拷贝时，仅仅拷贝地址，堆中的数据有被拷贝。 代码： 12345678910111213141516171819202122232425262728// 定义函数 参数fu，表示父对象 参数zi，表示子对象function copy(fu, zi) &#123; for (var key in fu) &#123; if (zi[key] == undefined) &#123; zi[key] = fu[key]; &#125; &#125;&#125;// 父对象var wjl = &#123; name: '王一', money: 100000000, houses: ['别墅1', '玩大2', '毛坯3', '瓦房4'], cars: ['宝马', '奔驰', '拖拉机', '三蹦子']&#125;;// 子对象1var wsc = &#123; name: '王二'&#125;// 子对象var wxc = &#123; name: '王三'&#125;copy(wjl, wsc);copy(wjl, wxc); 1.2 深拷贝 深拷贝：在堆中开辟新的空间拷贝堆中父对象的数据，在栈中开辟新的空间存堆空间中数据的地址 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 参数fu，表示父对象// 参数zi，表示子对象function copy(fu, zi) &#123; for (var key in fu) &#123; if (zi[key] == undefined) &#123; zi[key] = fu[key]; &#125; &#125;&#125;// 参数fu，表示父对象// 参数zi，表示子对象function deepCopy(fu, zi) &#123; for (var key in fu) &#123; if (zi[key] == undefined) &#123; // 判断是否是数组 if (fu[key] instanceof Array) &#123; // 子对象要开辟新的空间存放数组 zi[key] = new Array(); // 把父对象数组中成员 拷贝 到子对象的数组中 copy(fu[key],zi[key]) // 区别 &#125; else &#123; zi[key] = fu[key]; &#125; &#125; &#125;&#125;// 父对象var wjl = &#123; name: '王大', money: 100000000, houses: ['别墅1', '玩大2', '毛坯3', '瓦房4'], cars: ['宝马', '奔驰', '拖拉机', '三蹦子']&#125;;// 子对象1var wsc = &#123; name: '王二'&#125;// 子对象var wxc = &#123; name: '王三'&#125;deepCopy(wjl, wsc);deepCopy(wjl, wxc); 深拷贝–递归 1234567891011121314151617181920212223242526272829303132333435363738// 参数fu，表示父对象// 参数zi，表示子对象function deepCopy(fu, zi) &#123; for (var key in fu) &#123; if (zi[key] == undefined) &#123; // 判断是否是数组 if (fu[key] instanceof Array) &#123; // 子对象要开辟新的空间存放数组 zi[key] = new Array(); // 把父对象数组中成员 拷贝 到子对象的数组中 deepCopy(fu[key],zi[key]) // 区别 &#125; else &#123; zi[key] = fu[key]; &#125; &#125; &#125;&#125;// 父对象var wjl = &#123;name: '王大',money: 100000000,houses: ['别墅1', '玩大2', '毛坯3', '瓦房4'],cars: ['宝马', '奔驰', '拖拉机', '三蹦子']&#125;;// 子对象1var wsc = &#123;name: '王二'&#125;// 子对象var wxc = &#123;name: '王三'&#125;deepCopy(wjl, wsc);deepCopy(wjl, wxc);","path":"2017/05/28/浅拷贝和深拷贝/","date":"05-28","excerpt":"","tags":[{"name":"javascript","slug":"javascript","permalink":"http://diamond-sjh.github.io/tags/javascript/"}]},{"title":"函数内this指向以及改变this指向","text":"1、函数也是对象 函数的创建==&gt;底层都是new关键字创建函数 函数声明： 123function sum(a,b) &#123; console.log(a + b);&#125; 函数表达式： 123var sum = function sum(a,b) &#123; console.log(a + b);&#125; new关键字创建函数： 123// 语法：var 变量名 = new Function ('形参1'，'形参2'，...，'函数体中的代码')var sum = new Function('a','b','console.log(a + b)');sum(10,20); 2、函数内部this的指向 this的指向关键是看函数的调用方法 2.1 普通函数中this的指向 this指向window 代码： 1234567891011121314151617181920212223// 【在普通函数中this指向window】// function fn() &#123;// console.log(this);// &#125;// fn();// var fn = function() &#123;// console.log(this);// &#125;;// fn();// (function()&#123;// console.log(this);// &#125;)();function fn1() &#123; function fn2() &#123; console.log(this); &#125; fn2();&#125;fn1(); 2.2 构造函数中this的指向 this指向当前创建的对象—-在内存中开辟的空间 代码： 123456789101112 // 【在构造函数中this指向当前创建的对象】function Student(name,age) &#123; this.name = name; this.age =age;&#125;// 原型中添加方法Student.prototype.sayHi = function() &#123; console.log('我叫' + this.name);&#125;;var stu1 = new Student('张三',10); // ==&gt;this指向stu1var stu2 = new Student('李四',10); // ==&gt;this指向stu2 2.3 对象方法中的this指向 this指向调用者 代码： 123456789101112// 【在方法中，this指向调用者。 对象.方法（）】function Student(name,age) &#123; this.name = name; this.age =age;&#125;// 原型中添加方法Student.prototype.sayHi = function() &#123; console.log('我叫' + this.name);&#125;;var stu1 = new Student('张三',10); // ==&gt;this指向stu1stu1.sayHi(); // ==&gt;方法sayHi中的this指向stu1 2.4 定时器中this的指向 this指向window 代码： 1234// 【在定时器中this指向windnow】setTimeout(function()&#123; console.log(this);&#125;,5000); 2.5 事件处理程序中this指向 this指向事件源 代码： 1234// 【在事件处理程序中，this指向事件源】document.onclick = function() &#123; console.log(this);&#125;; 3、改变this的指向3.1 call方法 语法：函数名.call(调用者，实参1…) 作用：函数被借用时，会立即执行，并且函数体内的this会指向调用者(借用者) 代码： 123456789function fn(name, age) &#123; this.name = name; this.age = age; console.log(this == obj); //==&gt;true&#125; // 对象字面量var obj = &#123;&#125;;fn.call(obj, '李四', 11); //==&gt;fn中的this指向obj 3.2 apply方法 语法：函数名.apply(调用者，[实参1，实参2,….]) ==&gt;参数以数组的形式 作用：函数被借用是，会立即执行，并且函数体内的this会指向调用者(借用者) 代码： 123456789function fn(name, age) &#123; this.name = name; this.age = age; console.log(this == obj); //==&gt;true&#125; // 对象字面量var obj = &#123;&#125;;fn.call(obj, ['李四', 11]); //==&gt;fn中的this指向obj 3.3 bind方法 语法：函数名.bind(调用者，实参1….) 作用：函数被借用时，不会立即执行，而是返回一个新的函数。需要自己手动调用新的函数。 代码： 1234567891011function fn(name, age) &#123; this.name = name; this.age = age; console.log(this == obj); //==&gt;true &#125; // 对象字面量 var obj = &#123;&#125;; var newFn = fn.bind(obj, '李四', 11); newFn();// fn.bind(obj, '李四', 11)(); 3.4 使用 代码： 123456789101112// this指向windowvar name = 'window';var obj = &#123;name = 'obj'&#125;;setTimeout(function()&#123; console.log(this.name); //==&gt;输出window&#125;,2000)// this指向objvar name = 'window';var obj = &#123;name = 'obj'&#125;;setTimeout(function()&#123; console.log(this.name); //==&gt;输出obj&#125;.bind(obj),2000) // bind不会立即执行 伪数组借用数组的push方法实现增加 代码： 12345678910111213var arr = [10,20,30,40];// arr.push(50); // push为数组中的方法var obj = &#123; 0:10, 1:20, 2:30, 3:40, length:4&#125;// console.log(arr instanceof Array); ==&gt;true// console.log(obj instanceof Array); ==&gt;false// Array.prototype.push ==&gt;构造函数Array的原型中的push方法Array.prototype.push.call(obj,50); // ==&gt;改变push中this指向为obj","path":"2017/05/20/函数内this指向以及改变this指向/","date":"05-20","excerpt":"","tags":[{"name":"javascript","slug":"javascript","permalink":"http://diamond-sjh.github.io/tags/javascript/"}]},{"title":"JS中简单的几种继承方法","text":"1、继承介绍 ES6之前没有方法直接实现继承，这里的继承是利用技巧方法来模拟实现； 作用：减少代码或简化代码 生活：子承父业 编程：类与类之间的关系。子类继承父类中的成员 不使用继承，类与类之间可能有重复的属性和方法： 学生类：姓名、年龄、性别、学号、打招呼、跑 医生类：姓名、年龄、性别、钱、打招呼、跑 老师类：姓名、年龄、性别、工号、打招呼、跑 …… 使用继承，把不同类之间相同的属性和方法重新定义为一个类的： 人类[父类]：姓名、年龄、性别、打招呼、跑 学生类[子类]→人类[父类] 医生类[子类]→人类[父类] 老师类[子类]→人类[父类] …… 2、原型继承 优缺点： 优点：完美继承了方法 缺点：无法完美继承属性 如何实现原型继承： ①先更改子类的原型prototype指向父类的一个实例对象。 子类.prototype = new 父类(); ②再给子类的原型(即new 父类())设置一个constructor指向该子类 子类.prototype.constructor = 子类； 图解： 代码： 1234567891011121314151617181920212223242526272829// 人类 → 父类 function Person() &#123; this.name = '名字'; this.age = 10; this.gender = '男'; &#125; Person.prototype.sayHi = function () &#123; console.log('你好'); &#125;; Person.prototype.eat = function () &#123; console.log('我会吃。。。'); &#125;; Person.prototype.play = function () &#123; console.log('我会玩'); &#125;; // 学生类 → 子类 function Student() &#123; this.stuId = 1000; &#125; // 子类的原型prototyp指向父类的一个实例对象 Student.prototype = new Person(); // 添加一个constructor成员 Student.prototype.constructor = Student; // 如何实现原型继承： // 给子类的原型prototype重新赋值为父类的一个实例对象。 // 利用了原型链上属性或方法的查找规则。 // 创建一个学生对象 var stu1 = new Student(); console.log(stu1.constructor) 3、借用继承 本质就是改变父类构造函数中this指向子类(这里使用call方法)，子类调用父类属性 优缺点： 优点：完美继承了属性 缺点：无法继承方法。 3.1 call方法 语法： 函数名.call(调用者,函数实参，函数的实参...); 作用：该函数会立即执行，函数体内的this在被call时，this指向调用者。 代码： 12345678function Person(userName,age) &#123; console.log(this===obj); this.userName = userName; this.age = age; &#125; // 需求：通过一种方式调用执行Person函数，并且函数内部this代表obj var obj = &#123;&#125;; // new Object() Person.call(obj,'张三',10); //==&gt;Person中的this指向obj 3.2 使用call实现借用继承 如何实现： 在子类中，通过call调用父类，并更改父类中this的指向子类对象。 图解： 代码： 1234567891011121314151617181920212223242526// 人类 → 父类 function Person(name,age,gender) &#123; this.name = name; this.age = age; this.gender = gender; &#125; Person.prototype.sayHi = function () &#123; console.log('hello'); &#125;; Person.prototype.eat = function () &#123; console.log('eat。。。'); &#125;; Person.prototype.play = function () &#123; console.log('play'); &#125;; // 学生类 → 子类 function Student(name,age,gender,stuId) &#123; // this关键字代表谁,代表的是一个学生对象，当前创建的对象 stu1 ,stu2 // var obj = this; //【借用继承】 // Person.call(obj,name,age,gender); Person.call(this,name,age,gender); this.stuId = stuId; &#125; // 创建第一个学生对象 var stu1 = new Student('张三',15,'男',1006); // 创建第二个学生对象 var stu2 = new Student('李四',16,'女',1005); 3.3 利用apply实现继承(同上) 代码： 12345678910function person(name,age) &#123; this.name = name; this.age = age; &#125; function man(name,age)&#123; person.apply(this,[name,age]); //这里就是伪造成 person 的一个事例 &#125; var Man = new man('wozien',12); console.log(Man.name); console.log(Man.age); 4、组合继承 如何实现： 原型继承和借用继承同时使用。 代码： 123456789101112131415161718192021222324252627// 人类 → 父类function Person(name,age,gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;Person.prototype.sayHi = function () &#123; console.log('hello'); &#125;;Person.prototype.eat = function () &#123; console.log('eat'); &#125;;Person.prototype.play = function () &#123; console.log('play'); &#125;; // 学生类 → 子类function Student(name,age,gender,stuId) &#123; //【借用继承】 Person.call(this,name,age,gender); this.stuId = stuId;&#125; // 【原型继承】Student.prototype = new Person();Student.prototype.constructor = Student; // 创建第一个学生对象var stu1 = new Student('张三',16,'男',1006);// 创建第二个学生对象var stu2 = new Student('李四',15,'女',1005);","path":"2017/04/15/JS中简单的几种继承方法/","date":"04-15","excerpt":"","tags":[{"name":"javascript","slug":"javascript","permalink":"http://diamond-sjh.github.io/tags/javascript/"}]},{"title":"原型","text":"1、了解学习原型的目的 问题：若不用原型，则会产生内存浪费问题。 原因：方法放在构造函数中，每次new时，都会向对象中添加方法。 解决方案：把方法放到原型中，就可以让同类型的对象共享 。 2、什么是原型 原型就是一个对象(系统为函数所分配的一个对象)，原型一直都在。 获取原型： 语法： 构造函数名.prototype 3、构造函数和原型的关系 理论： 构造函数可以通过 prototype 获取到原型 原型可以通过 constructor 找到构造函数 图解： 代码： 12345678910111213141516// 学生类→ 构造函数 function Student(name,age,gender) &#123; // 属性 this.name = name; this.age = age; this.gender = gender; &#125; // 获取原型 // 每一个函数都有一个对应的原型 var yx = Student.prototype; console.log(yx); // 原型是一个对象 // 自带了一个成员：constructor → 构造函数 console.log(yx.constructor === Student); 4、构造函数、实例对象和原型的关系 关系： 构造函数可以通过prototype获取原型 实例对象可通过new关键字调用构造函数创建 实例对象在查找方法时可以通过__proto__ 进入原型中查找 一个对象调用属性和方法的过程： ① 首先，会从对象本身中去找 ② 若对象中，找不到，则会通过__proto__所提供的原型地址，找原型 ③ 去原型中查找。 向原型中添加方法： 语法：原型.key =value; 实例：jQyery中自定义插件； 图解： 代码： 123456789101112131415161718192021222324252627282930// 学生类→ 构造函数function Student(name, age, gender) &#123; // 属性 this.name = name; this.age = age; this.gender = gender;&#125; // 获取原型 ，每一个函数都有一个对应的原型var yx = Student.prototype; // 向原型中添加方法：对象.key = value// 方法1yx.sayHi = function () &#123; // 方法内部：this 代表的是调用方法的对象 console.log('我叫什么' + this.name)&#125;;// 方法2yx.writeCode = function () &#123; console.log('我会写code');&#125;// 属性yx.type = '学生'; // 创建对象var zs = new Student('张三', 10, '男');// 创建对象var ls = new Student('李四', 11, '男');// 创建对象var ww = new Student('王五', 17, '女'); 5、原型链 本质上就是一个实例对象访问一个属性或方法的完整过程 理论： ① 对象会先从本身查找相关的属性或方法 ② 若对象本身查找不到。则会通过系统给的__proto__进入原型中查找 ③ 若还查找不到，则通过原型中__proto_进入到原型的原型中查找 图解：","path":"2017/03/27/原型/","date":"03-27","excerpt":"","tags":[{"name":"javascript","slug":"javascript","permalink":"http://diamond-sjh.github.io/tags/javascript/"}]},{"title":"JS中的类和对象,new关键字","text":"1、什么是类 生活中：一类、种类 编程中： 类指的是抽象的名称(构造函数)：例如，狗🐶 class关键字，ES6之前没有类的概念。 在ES3或ES5中通过构造函数 来创建对象 构造函数： 内置的：Object、Date、Array等 自定义：例如，Dog…… 2、什么是对象 生活中：万物皆对象。任何具体的事和物都可以看成对象 编程中：对象由属性和方法组成（或由键值对）。 具体的实例，实例对象 属性：对象的静态特征，例如某人的，姓名、年龄、身高、性别等 方法：对象的功能特征，例如某人，画画、写代码等 注意事项： 方法的值用什么表示，用函数来表示 对象方法中的this，指向调用者。 3、类(构造函数)和对象的关系 类是对象的模板 对象是类的具体实例（通过关键字 instanceof 检测一个对象是否属于某一个类型） 语法：对象名 instanceof 构造函数名; 返回布尔值 创建对象得通过类（构造函数）创建 new 构造函数() → 具体的实例(实例对象) 4、创建对象 语法：自定义构造函数（类） 12345function 构造函数名(行参...)&#123; this.key = value； .......&#125;// 注意规范：构造函数名首字母要大写 帕斯卡（每个单词首字母大写） 驼峰（从第二个单词开始首字母大写） 语法：new关键字创建对象 1var 对象名 = new 构造函数名(实参...); 5、new关键字的执行过程 构造函数在执行时，内部的this指向当前创建的对象 过程： 首先会向内存申请一块空间，存放对象。 this关键字会指向内存中存放对象的空间。（this代表了当前创建的对象） 通过this关键字向内存中的对象中添加属性和方法 会把this返回给外部接收的变量 图解： 代码： 12345678910111213141516171819//构造函数function Student(name,age,gender) &#123; // 属性 this.name = name; this.age = age; this.gender = gender; // 方法 this.sayHi = function() &#123; // 方法内部：this 代表的是调用方法的对象 console.log('我叫什么' + this.name) &#125;; this.writeCode = function() &#123; console.log('我会写code'); &#125;&#125;// 创建对象var zs = new Student('张三',10,'男');// 使用对象zs.writeCode();","path":"2017/03/20/JS中的类和对象/","date":"03-20","excerpt":"","tags":[{"name":"javascript","slug":"javascript","permalink":"http://diamond-sjh.github.io/tags/javascript/"}]},{"title":"FormData对象","text":"H5新增FormData对象FormData是h5中新增的一个内置对象。 FormData对象用以将数据编译成键值对，以便用XMLHttpRequest来发送数据。其主要用于发送表单数据，但亦可用于发送带键数据(keyed data)，而独立于表单使用。 以前 AJAX 操作只能提交字符串，现在可以提交 二进制 的数据 使用方法一（有form表单） 1234567891011121314151617181920212223242526272829303132&lt;form id=\"fm\"&gt; &lt;input type=\"text\" name=\"user\"&gt;&lt;br&gt; &lt;input type=\"password\" name=\"pwd\"&gt;&lt;br&gt; &lt;input type=\"radio\" name=\"sex\" value=\"男\" checked&gt;男 &lt;input type=\"radio\" name=\"sex\" value=\"女\"&gt;女&lt;br&gt; &lt;input type=\"file\" name=\"pic\"&gt;&lt;br/&gt; &lt;input type=\"button\" id=\"btn\" value=\"提交\"&gt;&lt;/form&gt;&lt;script&gt; // 当点击提交按钮的时候，获取表单各项的值，然后将他们发送给服务器 document.getElementById('btn').onclick = function () &#123; // 获取表单各项的值 /* var user = document.getElementsByName('user')[0].value; var pwd = document.getElementsByName('pwd')[0].value; */ // 使用FormData来收集表单数据 // 1. 有表单，找到表单 var form = document.getElementById('fm'); // 2. 实例化FormData，将表单DOM对象传递给FormData var fd = new FormData(form); // fd对象，里面包含了表单中所有的值 // 把fd发送给服务器即可 var xhr = new XMLHttpRequest(); xhr.open('POST', '/fd'); // fd接口专门用于处理FormData类型的数据的 // xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.responseType = 'json'; xhr.send(fd); xhr.onload = function () &#123; console.log(this.response); &#125; &#125;&lt;/script&gt; ==上述使用FormData的时候，form表单中的各项必须有name属性。没有name属性是收集不到数据的== 使用方法二（没有form表单） 123456789101112131415161718192021222324252627282930&lt;input type=&quot;text&quot; id=&quot;user&quot;&gt;&lt;br&gt;&lt;input type=&quot;password&quot; id=&quot;pwd&quot;&gt;&lt;br&gt;&lt;input type=&quot;file&quot; id=&quot;pic&quot;&gt;&lt;br/&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;&lt;script&gt; // 点击提交按钮的时候，收集表单各项的数据，然后将他们发送给fd接口 document.getElementById(&apos;btn&apos;).onclick = function () &#123; // 1. 没有form，只能先实例化FormData var fd = new FormData(); // 2. 调用fd提供的append方法，向fd对象中，添加值 // fd.append(&apos;key&apos;, &apos;value&apos;); fd.append(&apos;username&apos;, document.getElementById(&apos;user&apos;).value); fd.append(&apos;pwd&apos;, document.getElementById(&apos;pwd&apos;).value); // 如果是文件的话，value值必须使用文件对象 // 获取文件对象 // console.dir(document.getElementById(&apos;pic&apos;)); var fileObj = document.getElementById(&apos;pic&apos;).files[0]; // fd.append(&apos;myfile&apos;, 文件对象); fd.append(&apos;myfile&apos;, fileObj); var xhr = new XMLHttpRequest(); xhr.open(&apos;POST&apos;, &apos;/fd&apos;); xhr.responseType = &apos;json&apos;; xhr.send(fd); xhr.onload = function () &#123; console.log(this.response); &#125; &#125;&lt;/script&gt; jQuery中使用FormData： 123456789101112131415161718192021222324252627282930313233343536373839&lt;form id=\"fm\"&gt; &lt;input type=\"text\" name=\"user\"&gt;&lt;br&gt; &lt;input type=\"password\" name=\"pwd\"&gt;&lt;br&gt; &lt;input type=\"radio\" name=\"sex\" value=\"男\" checked&gt;男 &lt;input type=\"radio\" name=\"sex\" value=\"女\"&gt;女&lt;br&gt; &lt;input type=\"file\" name=\"pic\"&gt;&lt;br /&gt; &lt;input type=\"button\" id=\"btn\" value=\"提交\"&gt; &lt;/form&gt; &lt;script src=\"/jquery.js\"&gt;&lt;/script&gt; &lt;script&gt; $('#btn').click(function () &#123; var fm = $('#fm'); var fd = new FormData(fm[0]); // 这里fm必须是DOM对象 console.log(fd); $.ajax(&#123; type: 'post', url: '/fd', // 如果data使用的是对象，ajax方法会把对象转成字符串， // 即把&#123;name: 'zs', age: 18&#125;转成name=zs&amp;age=18 // data: &#123;name: 'zs', age: 18&#125;, data: fd, // processData: false, 表示不让jQuery把fd对象转成字符串，而是直接发送fd对象 processData: false, // contentType：false，表示不让jQuery去设置content-type，让FormData去处理 contentType: false, success: function (res) &#123; console.log(res); &#125; &#125;); &#125;); // xhr.send('name=zs&amp;age=18'); &lt;/script&gt; 参考链接： https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects","path":"2017/01/28/FormData对象/","date":"01-28","excerpt":"","tags":[{"name":"H5","slug":"H5","permalink":"http://diamond-sjh.github.io/tags/H5/"}]},{"title":"正则表达式","text":"1、正则表达式 特点： 灵活性、逻辑性和功能性非常的强 可以迅速地用极简单的方式达到字符串的复杂控制 特点： 给定的字符串是否符合正则表达式的过滤逻辑(匹配) 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取) 强大的字符串替换能力(替换) 1.1 什么是正则表达式​ 正则表达式Regular Expression：正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 ​ 正则表达式在其他语言中也广泛应用。 正则表达式，就是定义好一个字符串规则 ，然后根据规则实现对象字符串的匹配、提取、替换等 1.2 正则表达式语法1.2.1 正则表达式的组成 普通字符abc 123 我爱你 特殊字符(元字符、限定符、中括号)：正则表达式中有特殊意义的字符 1.2.2 元字符​ 元字符就是，在正则表达式中具有特殊含义的字符。 元字符 说明 \\d 匹配数字 \\D 匹配非数字 \\w 匹配字母或数字或下划线_ \\W 匹配非字母、数字、下划线_ \\s 匹配空白符（空格） \\S 匹配非空白符 . 匹配任意除了回车换行符之外的单个字符 1.2.3 限定符控制字符出现的个数。 限定符 说明 n* 匹配任何包含零个或多个 n 的字符串。n{0,}。 若找到最后，字符串后面没有任何东西也算符合。 若有符合正则值，按照最多的匹配。 n+ 匹配任何包含至少一个 n 的字符串。{1,} 。 n? 匹配任何包含零个或一个 n 的字符串。{0,1} 若找到最后，字符串后面没有任何东西也算符合。若有符合正则值，按照1个匹配 n{x} 匹配包含 x 个 n 的序列的字符串 n{x,} 匹配包含至少 x 个 n 的序列的字符串。 n{x,y} 匹配包含 至少x个 至多 y 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串 ^n 匹配任何开头为 n 的字符串 注意： ==^正则表达式$== 使用时，会对字符串整体校验，完全符合才能够匹配。否则，不匹配。 在使用花括号限制字符个数时，将来在去匹配时，首先从前向后匹配，先按照至多的要求匹配，至多不满足时，再降低要求匹配，若将至最少时还不匹配→ 最终是不匹配。 关于次数至少是0时，表示的有没有都符合。 没有符合，内容不是也符合 1.2.4 中括号一个中括号就代表一个字符，中括号的目的就是控制了一个字符的范围。 对象字符种类限制 中括号 说明 [abc] 查找一个方括号之间的任何字符。 [ ^abc] 查找一个任何不在方括号之间的字符。^在中括号中有取反的意思 [0-9] 查找一个任何从 0 至 9 的数字。 [a-z] 查找一个任何从小写 a 到小写 z 的字符。 [A-Z] 查找一个任何从大写 A 到大写 Z 的字符。 [A-z] 查找一个字母（包含大小写和下划线） [\\u4e00-\\u9fa5] 查找一个汉字 ​ 在匹配时，从前向后按照【规则】去找，若是全局匹配，前面若有满足项时，后面再匹配时，从满足项下一个开始匹配。 1.2.5 或模式特殊符号：正则1|正则2, 或者。 符合或两边其中一个就可以匹配。 如：google，baidu，bing; // 匹配三种其中一种字符串 正则：google|baidu|bing 1.2.6 分组模式特殊符号：(正则); 组指的是一个小集体，分组就是将一个大集体可以分成几个小集体。 如：控制bruce连续出现的次数，最少1次，最多3次 正则：^(bruce){1,3}$ 1.2.7 修饰符→ g g，全称global，有 全局 的意思，表示全局匹配。 如： var reg = /hello/g;→ i i，全称ignore，有 忽视、忽略 的意思，表示匹配字母时，可以忽略字母的大小写。​ 如： var reg = /hello/i; → gi ig gi，全局匹配和忽略大小写一起使用。 如： var reg = /hello/gi; 1.2.8 正则转义符“.”在正则中表示特殊符号。去除.的特殊意义，需要转义： \\ . 1.3 js中使用正则表达式1.3.1 正则表达式对象 创建正则表达式对象 方式1： 语法：var 变量 = new RegExp(“规则”,”修饰符”); 代码： 1var reg = new RegExp('\\\\d','g'); 方式2：字面量或直接量 语法：var 变量 = /正则表达式/; 代码： 1var reg = /\\d/g; 检测匹配 正则对象.test(字符串) ; 用于检测字符串是否匹配某个规则。返回true和false。 1.3.2 字符串对象方法相关正则使用 字符串.match(正则对象); 提取所有匹配的内容获取匹配正则的子字符串，返回一个数组。 字符串.replace(正则对象,替换后的内容);​ 替换所匹配正则的子字符串。返回替换后的字符串。","path":"2016/12/28/正则表达式/","date":"12-28","excerpt":"","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://diamond-sjh.github.io/tags/正则表达式/"}]},{"title":"git的push端口错误解决","text":"出现的问题：Git Bash 控制行命令： git push 向远程git仓库ssh地址推送的时候，命令行提示Connection reset by 52.74.223.119 port 22，而git push 向远程git仓库http地址推送的时候正常推送 问题如图所示： 解决的方法：在window防火墙设置22端口1、window10安全中心–&gt;高级设置 2、入站规则–&gt;新建规则 3、选择端口 4、端口输入22 5、选择允许连接 6、下一步 7、添加名称和描述（随意填写）","path":"2016/11/20/git的push端口错误解决/","date":"11-20","excerpt":"","tags":[{"name":"git","slug":"git","permalink":"http://diamond-sjh.github.io/tags/git/"}]},{"title":"git基础","text":"1、git和github是什么？git是一个工具（软件），github是一个代码托管平台，类似的还有码云 作用：我们可以在自己的电脑上通过git这个软件从github上下载（拉取）代码，也可以将我们本地电脑上的代码上传到github上。 2、github账号的注册：1.打开github官网：https://github.com 2.填入自己的信息，完成注册之后，登录(Sign in)上就ok了。 3、git的安装：1、根据自己电脑情况，选择应该安装的软件。 2、下载地址：https://git-scm.com/downloads 3、一路next安装即可。 4、在命令行中输入以下命令查看 Git 是否安装成功。 123$ git --version# 如果看到类似 git version 2.21.0.windows.1 ，表示安装成功了 5、安装完成之后，在电脑任何一个位置，点击鼠标右键，会多了两个选项： ​ – Git GUI Here ​ – Git Bash Here Git GUI Here 的作用是，在此创建一个可视化的git窗口，用来上传或拉取代码或其他操作 Git Bash Here 的作用是，在此创建一个git命令行窗口，用来上传或拉取代码或其他操作 6、我们经常使用的是Git Bash Here 这个命令行窗口，在里面输入一些命令就可以进行操作。 4、使用Git管理自己的代码 初次使用Git，会让我们配置用户的信息，配置方式如下： 123# --global 会将配置项保存到用户配置$ git config --global user.name \"xxx\"$ git config --global user.email \"xxx\" 4.1 git名词解读：Workspace : 工作区 工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 Index / Stage : 暂存区 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’’，不过一般说法还是叫暂存区域。 Repository ： 仓库区（本地仓库） Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 Remote ： 远程仓库 工作区新建的文件和Git没有任何关系；文件被添加到暂存区，才叫做被Git管理过 代码不能越过暂存区而直接从工作区提交到仓库区 Untracked files：未跟踪 表示还没有被 Git 管理过，既没有进入过暂存区，更没有进入过仓库区。 staged：已暂存 表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 committed：已提交 表示数据已经安全的保存在本地数据库中。 modified：已修改 表示修改了暂存区的文件，但还没提交到仓库区。 4.2 git常用命令：git clone 仓库地址 — 用来从远程仓库（github）上克隆项目 git init —- 初始化（新建仓库区（本地仓库）），在本地电脑的一个文件夹中执行此命令，会生成一个叫.git的隐藏文件夹 git pull 仓库地址 —– 用来从远程仓库中下载代码 和clone很相似 git add . —– 将本地项目中新增、修改的文件添加到暂存区中，注意，后面是个英文状态下的点符号 git commit -m ‘描述’ —— 提交暂存区的代码到仓库区（本地仓库），并添加将要提交的描述 git push 仓库地址 —– 将暂存区的代码上传到远程仓库（github）中 4.3 进阶命令：状态操作：gitk —- 查看状态 git status —- 显示有变更的文件 git log —- 显示当前分支的版本历史 git log –oneline —- 简略查看历史版本 分支操作：git branch —- 查看当前分支 （默认是master分支 – 主分支） git branch 分支名 —– 创建一个分支（注意：目前我们创建分支，必须在master分支上去创建） git checkout 分支名 —- 切换分支 git checkout -b 分支名 —- 创建并切换分支 git merge 分支名 —- 将你想要合并的分支合并到当前分支上 git push origin 【空格】【冒号】【需要删除的分支名字】—通过代码删除远程分支 撤销操作：git checkout [file] —- 恢复暂存区的指定文件到工作区 git checkout . —- 恢复暂存区的所有文件到工作区 git checkout [commit] [file] —- 恢复某个commit的指定文件到暂存区和工作区 git reset [file] —- 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变 git reset –hard —- 重置暂存区与工作区，与上一次commit保持一致 拉取和更新：git pull —- 拉取远程代码到当前分支，并和本地分支合并 git pull [remote] [branch] —- 取回远程仓库的变化，并与本地指定分支合并 需要注意的是，我们平时在实际工作中，是不允许对主分支的东西进行操作的，也千万不要对主分支进行合并、提交、更新等。我们需要创建另外一个分支（测试分支），然后在这个分支中去合并其他组员的分支，最终将测试分支中的代码放到服务器上去测试、运行 4.4 示例：仓库地址示例：git@github.com:AIMIYue.git / https://gitee.com/ityuer/test.git 组长和组员需要执行以下命令： 1.git clone git@github.com:AIMIYue.git —- 克隆项目（拉取代码，虽然没什么代码） 2.git branch — 查看分支 3.git branch zhangsan 、git branch lisi 、 git branch wangwu — 创建以自己姓名命名的分支，好区分 4.git branch — 再次查看分支 看有没有创建成功。绿色的是当前的分支，白色的是未被选中的其他分支 5.git checkout zhangsan — 切换到自己的分支，这里是切换到了张三的分支上 6.测试下看能不能在自己的分支上提交代码，在你的文件夹中新建一个文件，然后执行第七步 7.git add . — 将自己创建、修改、删除的文件添加到暂存区 8.git commit -m ‘first comit’ —- 进行提交（提交到本地仓库），并写上提交信息 9.git push git@github.com:AIMIYue.git — 上传代码，上传完成后去github上刷新查看有没有自己的分支及自己的代码 10.如果成功的话，那么接下来就可以进行代码开发了，自己不断的写代码，写完了之后执行上述步骤（从第五步开始） 11.项目开发完成后，组长需要新建分支，然后合并自己和其他组员的分支，命令见下一步 git branch dev —- 创建测试分支，用来合并代码 git checkout dev — 切换到dev分支上 git merge origin/zhangsan 、 git merge origin/lisi 、 git merge origin/wangwu — 合并远程分支 git add. — 添加到暂存区 git commit -m ‘测试分支提交’ — 提交测试分支 git push git@github.com:AIMIYue.git — 将测试分支上传到仓库中 此时，项目已经完成，各组员可以各自从dev分支上拉取代码，然后运行就可以了 4.5 注意事项：1.当创建完分支后，远程仓库不会有分支（因为此时创建的是本地分支），需要切换到新创建的分支，然后进行一次代码提交，远程仓库才会有你新创建的分支 2.进行代码提交，必须按照严格的顺序执行命令，不允许颠倒(add–&gt;commit–&gt;push) 3.每次add之前，要先看一下你目前处于哪个分支，可使用git branch查看，在命令行中的每句话末尾也都会有分支标识 4.如果不小心add了，发现分支错了，或者不小执行了add命令，需要使用 git rm –cached 文件名 命令将add的文件从缓存区中删除。也可以使用 git rm -r –cached 文件名 命令删除某一个文件夹下的文件 5.创建并切换分支可以合并为一个命令，例如：git checkout - b zhangsan 6.可以使用git status 来查看发生变动的文件 7.小组项目的分支创建，一定要在master分支上去创建其他的分支！ 关于更为详细的git的其他命令，可点击下方链接： 链接：http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html https://www.liaoxuefeng.com/wiki/896043488029600 layui：https://www.layui.com/ layer：http://layer.layui.com/ JQUI：https://www.jqueryui.org.cn/tutorial/27.html","path":"2016/10/28/git基础/","date":"10-28","excerpt":"","tags":[{"name":"git","slug":"git","permalink":"http://diamond-sjh.github.io/tags/git/"}]}]}