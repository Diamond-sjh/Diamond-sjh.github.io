---
title: 回调函数闭包递归
date: 2017-06-15 16:21:53
tags: javascript
categories: 笔记总结
---

<meta name="referrer" content="no-referrer"/>

### 1、函数作为函数参数(回调函数)

- 现象：把一个函数B当做实参，传递给另一个函数的A的形参，并在函数A内部调用

- 参数：

  - 形参：函数定义时，小括号中的标识符
  - 实参：函数调用时，小括号中实际的数据
  - 关系：实参代表的实际数据传递给函数内部的形参使用。
  - 应用场景：当外部向函数内部传入数据时。

- 代码：

  ```javascript
  // 定义函数A
  // v是形参
  function A(v) {
      v(11,22);
  }
  // 调用
  A(
    //	函数B
    function (a,b) {
      console.log(a + b);
    }
  );
  ```

- 图解：

  ![回调函数闭包递归01](回调函数闭包递归01.png)

  ![回调函数闭包递归02](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ee7ea9e5-fad6-4763-8b50-eb42c2c0bed7/c7859f91-c45c-40c0-896f-bcbfc157176a.bmp)

### 1.2 函数作为函数的返回值

- 关键字：return 数据;

- 应用：函数内部要把结果暴露给外部时使用返回值

- 代码：

  ```javascript
  // 【返回值是函数时】
   function fn() {
     return function(){
             console.log('我是内部的的函数');
            };
   }
   // 调用函数
   var r = fn();
   r();
  ```

- 图解：

  ![回调函数闭包递归03](回调函数闭包递归03.png)

### 3、闭包

- 变量的生命周期：什么时候在内存中被释放

  - 全局变量的生命周期：程序关闭。
  - 局部变量的生命周期：函数执行结束后。

- 作用域：

  - 内层 可以 访问 外层，反之不行

- **闭包的作用**：

  - 目的**延长局部变量的生命周期**
  - 维护私有变量-局部变量的安全
  - GC（Garbage Collection）垃圾回收机制
    - 回收没有用的数据。
    - 有用的数据：被全局中操作的变量。

- 闭包的概念：

  - MDN：闭包是函数和声明该函数的词法环境的组合。

  - 百度百科：

    ​		闭包(Closure)就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取[局部变量](https://baike.baidu.com/item/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/9844788)，所以闭包可以理解成“定义在一个[函数](https://baike.baidu.com/item/%E5%87%BD%E6%95%B0/301912)内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的==桥梁==。

  - 总结：桥梁

- 代码：

  ```javascript
  // 生活：藏在别墅中的三儿，被外部的朝阳群众操作了。
   function bieShu () {
     var a = '三儿';  // 局部变量
     var guanJia = function() {
       console.log(a);  // 操作了外部的局部变量
     };
     return guanJia;   // 返回了子函数的地址
   }
   var cyqz = bieShu();  // 接收了子函数的地址
   cyqz();
  ```

  

- 图解：

  ![回调函数闭包递归04](回调函数闭包递归04.png)

  ![回调函数闭包递归05](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ee7ea9e5-fad6-4763-8b50-eb42c2c0bed7/f13e1718-a197-4018-a823-37d7ac761981.bmp)

- 如何检测一个程序是否存在闭包

  1. 外层函数  和  子函数
  2. 外层函数必须有局部变量
  3. 子函数要操作外层函数的局部变量
  4. 让子函数和外部产生关联（关联不一定是返回函数）

  - 或者，
    1. 浏览器F12打开开发者工具
    2. 点到 Sources 一栏
    3. 打开html文档
    4. 在子函数内部设置断点，刷新
    5. 检查右边的 Scope
    6. 存在Closure即存在闭包

### 4、递归

> - 递归的优点：减少代码量
> - 递归的缺点：消耗内存，内存栈溢出,报错！

#### 4.1 什么是递归

- 函数调用自身的编程技巧。

- 官方概念

  > 程序调用自身的编程技巧称为递归（ recursion）**。递归做为一种[算法](https://baike.baidu.com/item/%E7%AE%97%E6%B3%95)在[程序设计语言](https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80)中广泛应用。 一个过程或[函数](https://baike.baidu.com/item/%E5%87%BD%E6%95%B0)在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，**大大地减少了程序的代码量** 。递归的能力在于用有限的[语句](https://baike.baidu.com/item/%E8%AF%AD%E5%8F%A5)来定义对象的[无限集合](https://baike.baidu.com/item/%E6%97%A0%E9%99%90%E9%9B%86%E5%90%88)。一般来说，递归需要有==**边界条件**== 、==**递归前进段**== 和==**递归返回段**== 。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。

#### 4.2 递归的三个阶段

- 递归前进段
- 递归边界条件
- 递归返回段
- 案例：

例子1-- --如：一组有规律的年龄10 、12、14、16、18、20、22、24......，求第n个人的年龄

```javascript
// 规律：第n个人的年龄 = 第n-1个人的年龄 + 2

// 创建一个函数
function age(n) {
    if(n==1) {
        return 10;
    }else {
        return age(n-1) + 2;
    }
}
// 调用
var r = age(5);	//	若fn的形参超过一定数值，会导致内存栈溢出报错。如：age(5000)，系统会报错
console.log(r);
    
//  运行过程如下
//	-------------------------递归前进段
// age(5)      // 等待...
// age(4) + 2  // 等待...
// age(3) + 2  // 等待...
// age(2) + 2   // 等待...
// age(1) + 2


// age(1) 10	//	-------递归边界条件

//	-------------------------递归返回段
// age(2)  12
// age(3)  14
// age(4)  16
// age(5)  18
```

例子2-- --如：一组有规律的数字1、1、2、3、5、8、13....，求第n个数字

```javascript
// 规律：第n个数字的结果 = 第n-1个数字的结果 + 第n-2个数字的结果

function fn(n) {
    if(n==1||n==2) {
        return 1;
    }else {
        return fn(n-1) + fn(n-2);
    }
}

var r = fn(30);	//	若fn的形参超过一定数值，会导致内存栈溢出报错。如：fn(3000)，系统会报错
console.log(r);
```